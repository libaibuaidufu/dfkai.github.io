<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>cloudflare 动态修改 dns</title>
    <url>/post/cloudflare-%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9-dns.html</url>
    <content><![CDATA[<h3 id="首先申请-api-token"><a href="#首先申请-api-token" class="headerlink" title="首先申请 api-token"></a>首先申请 api-token</h3><ol>
<li>登陆进 <a href="http://www.cloudflare.com/">www.cloudflare.com</a></li>
<li>点击进入自己的域名</li>
<li>中文 概述 ，下滑找到 区域id (zone_id)复制保存， 点击下面的获取api令牌</li>
<li>进去创建令牌 ，选择dns模板</li>
<li>可以保持默认 直接创建，也可以在区域选择上指定 可操作 域名</li>
<li>得到令牌，后有一个测试curl命令 去测试一下</li>
</ol>
<a id="more"></a>

<p>已获得参数：</p>
<p>API_KEY =令牌token<br>ZONE_ID = 区域id<br>email = 自己的邮箱<br>-x 是 代理</p>
<h3 id="获取-指定-dns记录-id"><a href="#获取-指定-dns记录-id" class="headerlink" title="获取 指定 dns记录 id"></a>获取 指定 dns记录 id</h3><p><strong>注意替换下面的 参数 为自己的,&lt;&gt;也要去掉</strong> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;https://api.cloudflare.com/client/v4/zones/&lt;ZONE_ID&gt;/dns_records&quot;</span> \</span><br><span class="line">     -H <span class="string">&quot;X-Auth-Email:&lt;email&gt;&quot;</span> \</span><br><span class="line">     -H <span class="string">&quot;Authorization:Bearer &lt;API_KEY&gt;&quot;</span> \</span><br><span class="line">     -H <span class="string">&quot;Content-Type:application/json&quot;</span> </span><br></pre></td></tr></table></figure>

<p><strong>从上面返回的结果中找到你需要的域名的id 可通过 域名搜索</strong></p>
<p>获取到id：<br>dx = xxxx_id</p>
<h3 id="更新执行dns记录"><a href="#更新执行dns记录" class="headerlink" title="更新执行dns记录"></a>更新执行dns记录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X PUT <span class="string">&quot;https://api.cloudflare.com/client/v4/zones/&lt;ZONE_ID&gt;/dns_records/&lt;xxxx_id&gt;&quot;</span> \</span><br><span class="line">     -H <span class="string">&quot;X-Auth-Email:&lt;email&gt;&quot;</span> \</span><br><span class="line">     -H <span class="string">&quot;Authorization:Bearer &lt;API_KEY&gt;&quot;</span> \</span><br><span class="line">     -H <span class="string">&quot;Content-Type:application/json&quot;</span> </span><br><span class="line">     --data <span class="string">&#x27;&#123;&quot;type&quot;:&quot;A&quot;,&quot;name&quot;:&quot;dx.example.com&quot;,&quot;content&quot;:&quot;1.2.3.4&quot;,&quot;ttl&quot;:120,&quot;proxied&quot;:false&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="脚本处理"><a href="#脚本处理" class="headerlink" title="脚本处理"></a>脚本处理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># modify_dns.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">ip=<span class="string">&#x27;1.1.1.1&#x27;</span></span><br><span class="line">dns_id=<span class="string">&#x27;xxx_id&#x27;</span></span><br><span class="line">data=<span class="string">&#x27;&#123;&quot;type&quot;:&quot;A&quot;,&quot;name&quot;:&quot;dx.example.com&quot;,&quot;content&quot;:&quot;%s&quot;,&quot;ttl&quot;:120,&quot;proxied&quot;:false&#125;&#x27;</span></span><br><span class="line">str_data=$(<span class="built_in">printf</span> <span class="string">&quot;<span class="variable">$data</span>&quot;</span> <span class="string">&quot;<span class="variable">$ip</span>&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str_data</span></span><br><span class="line">url=$(<span class="built_in">printf</span> <span class="string">&#x27;https://api.cloudflare.com/client/v4/zones/&lt;zone_id&gt;/dns_records/&#x27;</span><span class="variable">$dns_id</span> )</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$url</span></span><br><span class="line">curl -X PUT <span class="variable">$url</span> \</span><br><span class="line">     -H <span class="string">&quot;X-Auth-Email:&lt;email&gt;&quot;</span> \</span><br><span class="line">     -H <span class="string">&quot;Authorization:Bearer &lt;API_KEY&gt;&quot;</span> \</span><br><span class="line">     -H <span class="string">&quot;Content-Type:application/json&quot;</span> </span><br><span class="line">     --data <span class="variable">$str_data</span></span><br></pre></td></tr></table></figure>

<h3 id="其他脚本-调用此脚本"><a href="#其他脚本-调用此脚本" class="headerlink" title="其他脚本 调用此脚本"></a>其他脚本 调用此脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">ip=<span class="string">&quot;1.2.3.4&quot;</span></span><br><span class="line"><span class="built_in">source</span> ./modify_dns.sh <span class="variable">$ip</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>cloudflare</tag>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title>next主题文章列表 显示摘要</title>
    <url>/post/My-New-Post.html</url>
    <content><![CDATA[<p>本文针对Next主题，不确保对于其它主题有效（但从修改模式来看，是有效的）</p>
<p>Next默认是会显示全文的，这样显然很不方便，因此需要一些方法去只显示前面一部分。</p>
<h1 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h1><p>首先需要在Next主题的_config.yml中把设置打开：(默认安装时就打开了)</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatically excerpt description in homepage as preamble text.</span></span><br><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>之后有两种方法</p>
<h2 id="方法一：写概述"><a href="#方法一：写概述" class="headerlink" title="方法一：写概述"></a>方法一：写概述</h2><p>在文章的<code>front-matter</code>中添加<code>description</code>，其中description中的内容就会被显示在首页上，其余一律不显示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 让首页显示部分内容</span><br><span class="line">date: 2020-02-23 22:55:10</span><br><span class="line">description: 这是显示在首页的概述，正文内容均会被隐藏。</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>比较不方便的是还得写一下概述，很多时候会懒得写概述，于是就需要第二种方法了。</p>
<h2 id="方法二：文章截断"><a href="#方法二：文章截断" class="headerlink" title="方法二：文章截断"></a>方法二：文章截断</h2><p>在需要截断的地方加入：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!--more--&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>首页就会显示这条以上的所有内容，隐藏接下来的所有内容。<br>例如本文会显示到<code>修改配置</code>上面。</p>
<p>这个明显就方便很多，但当然有利有弊，比如开头都是废话首页看着就不是很好看，因此我一般会先选择方法二，如果感觉文章前面的写的不太好再用方法一。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>flask rbac 设计</title>
    <url>/post/flask-rbac-%E8%AE%BE%E8%AE%A1.html</url>
    <content><![CDATA[<p>一直对rbac设计有点不确定，看了一些文章对他有一定的了解，因此也想动手写一写。</p>
<a id="more"></a>

<h3 id="flask-rbac-code"><a href="#flask-rbac-code" class="headerlink" title="flask rbac code"></a>flask rbac code</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging <span class="keyword">as</span> logger</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, g</span><br><span class="line"><span class="keyword">from</span> flask_admin <span class="keyword">import</span> Admin</span><br><span class="line"><span class="keyword">from</span> flask_admin.contrib.sqla <span class="keyword">import</span> ModelView</span><br><span class="line"><span class="keyword">from</span> flask_curd_db <span class="keyword">import</span> FlaskCurdDb</span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">&quot;SECRET_KEY&quot;</span>] = str(uuid.uuid4())</span><br><span class="line">app.config[<span class="string">&quot;SQLALCHEMY_DATABASE_URI&quot;</span>] = <span class="string">&quot;sqlite:///rbac.db&quot;</span></span><br><span class="line">app.config[<span class="string">&quot;SQLALCHEMY_TRACK_MODIFICATIONS&quot;</span>] = <span class="literal">True</span></span><br><span class="line">app.config[<span class="string">&#x27;FLASK_ADMIN_SWATCH&#x27;</span>] = <span class="string">&#x27;cerulean&#x27;</span></span><br><span class="line"></span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line">FlaskCurdDb(app, db, logger)</span><br><span class="line"></span><br><span class="line">admin = Admin(app, name=<span class="string">&#x27;flask-rbac&#x27;</span>, template_mode=<span class="string">&#x27;bootstrap3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask_curd_db.db <span class="keyword">import</span> CRUDMixin</span><br><span class="line"></span><br><span class="line">tb_user_role = db.Table(</span><br><span class="line">    <span class="string">&#x27;tb_user_role&#x27;</span>,</span><br><span class="line">    db.Column(<span class="string">&quot;role_id&quot;</span>, db.Integer, db.ForeignKey(<span class="string">&quot;tb_role.id&quot;</span>), nullable=<span class="literal">False</span>),</span><br><span class="line">    db.Column(<span class="string">&quot;user_id&quot;</span>, db.Integer, db.ForeignKey(<span class="string">&quot;tb_user.id&quot;</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">)</span><br><span class="line">tb_role_menu = db.Table(</span><br><span class="line">    <span class="string">&#x27;tb_role_menu&#x27;</span>,</span><br><span class="line">    db.Column(<span class="string">&quot;role_id&quot;</span>, db.Integer, db.ForeignKey(<span class="string">&quot;tb_role.id&quot;</span>), nullable=<span class="literal">False</span>),</span><br><span class="line">    db.Column(<span class="string">&quot;menu_id&quot;</span>, db.Integer, db.ForeignKey(<span class="string">&quot;tb_menu.id&quot;</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">)</span><br><span class="line">tb_menu_pemission = db.Table(</span><br><span class="line">    <span class="string">&#x27;tb_menu_pemission&#x27;</span>,</span><br><span class="line">    db.Column(<span class="string">&quot;menu_id&quot;</span>, db.Integer, db.ForeignKey(<span class="string">&quot;tb_menu.id&quot;</span>), nullable=<span class="literal">False</span>),</span><br><span class="line">    db.Column(<span class="string">&quot;pemission_id&quot;</span>, db.Integer, db.ForeignKey(<span class="string">&quot;tb_pemission.id&quot;</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">)</span><br><span class="line">tb_pemission_operation = db.Table(</span><br><span class="line">    <span class="string">&#x27;tb_pemission_operation&#x27;</span>,</span><br><span class="line">    db.Column(<span class="string">&quot;pemission_id&quot;</span>, db.Integer, db.ForeignKey(<span class="string">&quot;tb_pemission.id&quot;</span>), nullable=<span class="literal">False</span>),</span><br><span class="line">    db.Column(<span class="string">&quot;operation_id&quot;</span>, db.Integer, db.ForeignKey(<span class="string">&quot;tb_operation.id&quot;</span>), nullable=<span class="literal">False</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span>(<span class="params">db.Model, CRUDMixin</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&quot;tb_operation&quot;</span></span><br><span class="line">    name = db.Column(db.String(<span class="number">50</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pemission</span>(<span class="params">db.Model, CRUDMixin</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&quot;tb_pemission&quot;</span></span><br><span class="line">    name = db.Column(db.String(<span class="number">50</span>))</span><br><span class="line">    tb_pemission_operation = db.relationship(Operation, secondary=tb_pemission_operation,</span><br><span class="line">                                             backref=db.backref(<span class="string">&#x27;pemissions&#x27;</span>, lazy=<span class="string">&#x27;dynamic&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Menu</span>(<span class="params">db.Model, CRUDMixin</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;tb_menu&#x27;</span></span><br><span class="line">    name = db.Column(db.String(<span class="number">50</span>))</span><br><span class="line">    tb_menu_pemission = db.relationship(Pemission, secondary=tb_menu_pemission,</span><br><span class="line">                                        backref=db.backref(<span class="string">&#x27;menus&#x27;</span>, lazy=<span class="string">&#x27;dynamic&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span>(<span class="params">db.Model, CRUDMixin</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&quot;tb_role&quot;</span></span><br><span class="line">    name = db.Column(db.String(<span class="number">50</span>))</span><br><span class="line">    tb_role_menu = db.relationship(Menu, secondary=tb_role_menu,</span><br><span class="line">                                   backref=db.backref(<span class="string">&#x27;roles&#x27;</span>, lazy=<span class="string">&#x27;dynamic&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">db.Model, CRUDMixin</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&quot;tb_user&quot;</span></span><br><span class="line">    name = db.Column(db.String(<span class="number">50</span>))</span><br><span class="line">    tb_user_role = db.relationship(Role, secondary=tb_user_role,</span><br><span class="line">                                   backref=db.backref(<span class="string">&#x27;users&#x27;</span>, lazy=<span class="string">&#x27;dynamic&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">admin.add_view(ModelView(User, db.session))</span><br><span class="line">admin.add_view(ModelView(Role, db.session))</span><br><span class="line">admin.add_view(ModelView(Menu, db.session))</span><br><span class="line">admin.add_view(ModelView(Pemission, db.session))</span><br><span class="line">admin.add_view(ModelView(Operation, db.session))</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">UserLoginError</span>(<span class="params">BaseException</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, message, status</span>):</span></span><br><span class="line">        super().__init__(message, status)</span><br><span class="line">        self.message = message</span><br><span class="line">        self.status = status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">before_request</span>():</span></span><br><span class="line">    g.user = User.get_ins_by_id(<span class="number">1</span>)</span><br><span class="line">    print(g.user.name)</span><br><span class="line">    g.user_roles = g.user.tb_user_role</span><br><span class="line">    print(g.user_roles)</span><br><span class="line">    g.user_role_menus = []</span><br><span class="line">    <span class="keyword">for</span> role <span class="keyword">in</span> g.user_roles:</span><br><span class="line">        g.user_role_menus.extend(role.tb_role_menu)</span><br><span class="line">    g.user_role_menus = list(set(g.user_role_menus))</span><br><span class="line">    print(g.user_role_menus)</span><br><span class="line">    <span class="comment"># g.user_role_menu_pemissions = []</span></span><br><span class="line">    <span class="comment"># for menu in g.user_role_menus:</span></span><br><span class="line">    <span class="comment">#     g.user_role_menu_pemissions.extend(menu.tb_menu_pemission)</span></span><br><span class="line">    <span class="comment"># g.user_role_menu_pemissions = list(set(g.user_role_menu_pemissions))</span></span><br><span class="line">    <span class="comment"># print(g.user_role_menu_pemissions)</span></span><br><span class="line">    <span class="comment"># g.user_role_menu_pemission_operation = &#123;&#125;</span></span><br><span class="line">    <span class="comment"># for pemission in g.user_role_menu_pemissions:</span></span><br><span class="line">    <span class="comment">#     g.user_role_menu_pemission_operation[pemission.name] = [operation.name for operation in</span></span><br><span class="line">    <span class="comment">#                                                             pemission.tb_pemission_operation]</span></span><br><span class="line">    <span class="comment"># print(g.user_role_menu_pemissions)</span></span><br><span class="line">    g.user_role_menu_pemissions = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> menu <span class="keyword">in</span> g.user_role_menus:</span><br><span class="line">        <span class="keyword">for</span> pemission <span class="keyword">in</span> menu.tb_menu_pemission:</span><br><span class="line">            g.user_role_menu_pemissions[menu.name] = &#123;pemission.name: [operation.name <span class="keyword">for</span> operation <span class="keyword">in</span></span><br><span class="line">                                                                       pemission.tb_pemission_operation]&#125;</span><br><span class="line">    print(g.user_role_menu_pemissions)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.after_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">after_request</span>(<span class="params">reponse</span>):</span></span><br><span class="line">    <span class="keyword">return</span> reponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_require</span>(<span class="params">fn</span>):</span></span><br><span class="line"><span class="meta">    @wraps(fn)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dec</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> g.user.name == <span class="string">&quot;小黄&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> fn(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;滚回去登录！！！&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _dec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_operation_menu</span>(<span class="params">menu_name, pemission_name, operation_name</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">user_operation</span>(<span class="params">fn</span>):</span></span><br><span class="line"><span class="meta">        @wraps(fn)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_dec</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="keyword">if</span> menu_name <span class="keyword">in</span> g.user_role_menu_pemissions:</span><br><span class="line">                <span class="keyword">if</span> pemission_name <span class="keyword">in</span> g.user_role_menu_pemissions[menu_name]:</span><br><span class="line">                    <span class="keyword">if</span> operation_name <span class="keyword">in</span> g.user_role_menu_pemissions[menu_name][pemission_name]:</span><br><span class="line">                        <span class="keyword">return</span> fn(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;没权限，玩**呢！！！&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _dec</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> user_operation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/&#x27;)</span></span><br><span class="line"><span class="meta">@login_require</span></span><br><span class="line"><span class="meta">@user_operation_menu(&quot;用户管理&quot;, &quot;用户管理的权限&quot;, &quot;查看&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    db.create_all()</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="require-文件"><a href="#require-文件" class="headerlink" title="require 文件"></a>require 文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flask            1.1.2</span><br><span class="line">Flask-Admin      1.5.6</span><br><span class="line">Flask-Curd-Db    1.0.0</span><br><span class="line">Flask-SQLAlchemy 2.4.4</span><br></pre></td></tr></table></figure>

<h3 id="设计与理解"><a href="#设计与理解" class="headerlink" title="设计与理解"></a>设计与理解</h3><h4 id="本案例中"><a href="#本案例中" class="headerlink" title="本案例中"></a>本案例中</h4><p>到此 发现设计一个颗粒到按钮还是比较容易，但是如何使用才是关键，例如上面的这种使用方法就很繁琐。</p>
<p>如何验证到 【查看，删除，增加，修改】这一步的权限，需要进一步的思考更好的做法。</p>
<p>可以在operation表中加一个唯一key，或者 从菜单-权限-操作 这个 形成一个唯一key，或者在视图中来操作一个。</p>
<h4 id="以前看Lin-CMS-Flask学习到的"><a href="#以前看Lin-CMS-Flask学习到的" class="headerlink" title="以前看Lin-CMS-Flask学习到的"></a>以前看Lin-CMS-Flask学习到的</h4><p>对flask源码有一定了解的，可以知道 flask的 view_functions ，并且这些view_functions的function name是唯一的，然后利用一定的约束标准，对接口进行划分。直接在程序启动时，对函数名称进行收集，然后权限操作直接对应着函数名称。</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol>
<li><a href="https://juejin.im/entry/6844903540884766733">https://juejin.im/entry/6844903540884766733</a></li>
<li><a href="https://github.com/TaleLin/lin-cms-flask">https://github.com/TaleLin/lin-cms-flask</a></li>
</ol>
]]></content>
      <categories>
        <category>代码来了</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>rbac</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 的基础使用</title>
    <url>/post/hello-world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
  </entry>
  <entry>
    <title>flask源码分析(一)</title>
    <url>/post/flask%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%80.html</url>
    <content><![CDATA[<p>对于flask源码，已经看过几次，每次都是看了忘，忘了看，这次就好生记录一下。也算是认真学习。</p>
<a id="more"></a>

<h2 id="Flask-class"><a href="#Flask-class" class="headerlink" title="Flask class"></a>Flask class</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br></pre></td></tr></table></figure>

<p>一般 我们都是这样开头的，那我们就 从最开始的 <code>__name__</code> 开始介绍。</p>
<h3 id="Flask-的一个参数-import-name"><a href="#Flask-的一个参数-import-name" class="headerlink" title="Flask 的一个参数 import_name"></a>Flask 的一个参数 import_name</h3><p>通过进入源码了解到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admonition:: About the First Parameter</span><br><span class="line">        The idea of the first parameter is to give Flask an idea of what</span><br><span class="line">        belongs to your application.  This name is used to find resources</span><br><span class="line">        on the filesystem, can be used by extensions to improve debugging</span><br><span class="line">        information and a lot more.</span><br><span class="line"></span><br><span class="line">        So it&#39;s important what you provide there.  If you are using a single</span><br><span class="line">        module, &#96;__name__&#96; is always the correct value.  If you however are</span><br><span class="line">        using a package, it&#39;s usually recommended to hardcode the name of</span><br><span class="line">        your package there.</span><br><span class="line"></span><br><span class="line">        For example if your application is defined in :file:&#96;yourapplication&#x2F;app.py&#96;</span><br><span class="line">        you should create it with one of the two versions below::</span><br><span class="line"></span><br><span class="line">            app &#x3D; Flask(&#39;yourapplication&#39;)</span><br><span class="line">            app &#x3D; Flask(__name__.split(&#39;.&#39;)[0])</span><br><span class="line"></span><br><span class="line">        Why is that?  The application will work even with &#96;__name__&#96;, thanks</span><br><span class="line">        to how resources are looked up.  However it will make debugging more</span><br><span class="line">        painful.  Certain extensions can make assumptions based on the</span><br><span class="line">        import name of your application.  For example the Flask-SQLAlchemy</span><br><span class="line">        extension will look for the code in your application that triggered</span><br><span class="line">        an SQL query in debug mode.  If the import name is not properly set</span><br><span class="line">        up, that debugging information is lost.  (For example it would only</span><br><span class="line">        pick up SQL queries in &#96;yourapplication.app&#96; and not</span><br><span class="line">        &#96;yourapplication.views.frontend&#96;)</span><br><span class="line">##### 谷歌翻译</span><br><span class="line">告诫：：关于第一个参数</span><br><span class="line"></span><br><span class="line">        第一个参数的想法是让Flask了解属于您的应用程序。此名称用于查找资源在文件系统上，扩展可以使用它来改进调试信息等等。</span><br><span class="line"></span><br><span class="line">        因此，您在此处提供的内容很重要。如果您使用单个在模块中，“ __ name__”始终是正确的值。如果你是使用软件包，通常建议对代码名称进行硬编码您的包裹在那里。</span><br><span class="line"></span><br><span class="line">        例如，如果您的应用程序是在：file：&#96;yourapplication &#x2F; app.py&#96;中定义的</span><br><span class="line">        您应该使用以下两个版本之一创建它：：</span><br><span class="line">            app &#x3D; Flask(&#39;yourapplication&#39;)</span><br><span class="line">            app &#x3D; Flask(__name__.split(&#39;.&#39;)[0])</span><br><span class="line"></span><br><span class="line">        这是为什么？由于如何查找资源，该应用程序甚至可以与“ __name__”一起使用。但是，这会使调试更加痛苦。某些扩展可以根据您的应用程序的导入名称进行假设。例如，Flask-SQLAlchemy扩展将在您的应用程序中查找在调试模式下触发SQL查询的代码。如果导入名称设置不正确，则该调试信息将丢失。 （例如，它将仅在&#96;yourapplication.app&#96;中而不是&#96;yourapplication.views.frontend&#96;中拾取SQL查询。）</span><br></pre></td></tr></table></figure>

<h4 id="第一个参数-单模块"><a href="#第一个参数-单模块" class="headerlink" title="第一个参数 单模块"></a>第一个参数 单模块</h4><p>如果只是使用单模块，那么使用<code>__name__</code> 总是对的。</p>
<p>什么是单模块就是一个文件搞定所有。</p>
<h4 id="第一个参数-多内容"><a href="#第一个参数-多内容" class="headerlink" title="第一个参数 多内容"></a>第一个参数 多内容</h4><p>目录结构是：<br>├─.idea<br>│  └─inspectionProfiles<br>├─to_the_world_package<br>│  ├─static<br>│  └─templates<br>└─<strong>pycache</strong></p>
<p>file: <code>to_the_world_package/to-the-world.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"><span class="keyword">from</span> flask.helpers <span class="keyword">import</span> get_root_path</span><br><span class="line"><span class="keyword">from</span> .hello <span class="keyword">import</span> data</span><br><span class="line"></span><br><span class="line">print(__name__)</span><br><span class="line">app = Flask(<span class="string">&quot;to_the_world_package&quot;</span>)</span><br><span class="line"><span class="comment"># app = Flask(__name__.split(&quot;.&quot;)[0])</span></span><br><span class="line"><span class="comment"># app = Flask(__name__)</span></span><br><span class="line"></span><br><span class="line">print(app.import_name)</span><br><span class="line">print(app.template_folder)</span><br><span class="line">print(app.root_path)</span><br><span class="line">import_name = <span class="string">&quot;to_the_world_package&quot;</span></span><br><span class="line">mod = sys.modules.get(import_name)</span><br><span class="line">print(mod.__file__)</span><br><span class="line">print(os.path.abspath(mod.__file__))</span><br><span class="line">print(os.path.dirname(os.path.abspath(mod.__file__)))</span><br><span class="line"></span><br><span class="line">import_name = <span class="string">&quot;to_the_world_package.to-the-world&quot;</span></span><br><span class="line">mod = sys.modules.get(import_name)</span><br><span class="line">print(mod.__file__)</span><br><span class="line">print(os.path.abspath(mod.__file__))</span><br><span class="line">print(os.path.dirname(os.path.abspath(mod.__file__)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    print(data)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># app.run(debug=True, host=&#x27;0.0.0.0&#x27;, port=8080)</span></span><br><span class="line">    app.run(debug=<span class="literal">True</span>, port=<span class="number">8080</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">to_the_world_package.to-the-world</span></span><br><span class="line"><span class="string">to_the_world_package.to-the-world</span></span><br><span class="line"><span class="string">templates</span></span><br><span class="line"><span class="string">C:\Users\libai\dfk-common\日常\flask-rbac\to_the_world_package</span></span><br><span class="line"><span class="string"># import_name = &quot;to_the_world_package&quot;</span></span><br><span class="line"><span class="string">C:\Users\libai\dfk-common\日常\flask-rbac\to_the_world_package\__init__.py</span></span><br><span class="line"><span class="string">C:\Users\libai\dfk-common\日常\flask-rbac\to_the_world_package\__init__.py</span></span><br><span class="line"><span class="string">C:\Users\libai\dfk-common\日常\flask-rbac\to_the_world_package</span></span><br><span class="line"><span class="string"># import_name = &quot;to_the_world_package.to-the-world&quot;</span></span><br><span class="line"><span class="string">C:\Users\libai\dfk-common\日常\flask-rbac\to_the_world_package\to-the-world.py</span></span><br><span class="line"><span class="string">C:\Users\libai\dfk-common\日常\flask-rbac\to_the_world_package\to-the-world.py</span></span><br><span class="line"><span class="string">C:\Users\libai\dfk-common\日常\flask-rbac\to_the_world_package</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>从这里来看 无论使用  <code>__name__</code>  还是 packeage_name 还是 <code>__name__.split(&quot;.&quot;)[0]</code> 都可以，因为</p>
<p><code>get_root_path</code>方法 会把root_path给改回来。</p>
<p><strong>Flask 的第一个参数 主要是 为了 让Flask找文件位置，就是找到所谓的root_path，然后就可以找到root_path下的文件，例如 static 或者 templates,如果root_path位置不对，就会无法使用 static 或者 templates，因此可以自己设定位置,设定 static_folder，template_folder，或者直接设置root_path</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    self,</span></span></span><br><span class="line"><span class="function"><span class="params">    import_name,</span></span></span><br><span class="line"><span class="function"><span class="params">    static_url_path=None,</span></span></span><br><span class="line"><span class="function"><span class="params">    static_folder=<span class="string">&quot;static&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    static_host=None,</span></span></span><br><span class="line"><span class="function"><span class="params">    host_matching=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    subdomain_matching=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    template_folder=<span class="string">&quot;templates&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    instance_path=None,</span></span></span><br><span class="line"><span class="function"><span class="params">    instance_relative_config=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    root_path=None,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br></pre></td></tr></table></figure>

<h4 id="这里写一个真实的"><a href="#这里写一个真实的" class="headerlink" title="这里写一个真实的"></a>这里写一个真实的</h4><p>目录精简下来：</p>
<p>app:</p>
<p>├─.idea<br>│  └─inspectionProfiles<br>├─config<br>│  └─config.py<br>├─controllers<br>│  ├─app<br>│  ├─impl<br>│  ├─web<br>│  └─wx<br>├─log<br>├─models<br>├─static<br>│  └─dept_img<br>└─Main.py</p>
<p>我们在config目录下的 config.py中进行了配置，但是在主目录下Main.py进行注册启动。</p>
<p>因此 我们config下的config.py中如何写 Flask呢？</p>
<p>我去看看了以前的</p>
<h5 id="以前我们是设定template-folder-和-static-folder"><a href="#以前我们是设定template-folder-和-static-folder" class="headerlink" title="以前我们是设定template_folder 和 static_folder"></a>以前我们是设定template_folder 和 static_folder</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app = Flask(__name__, template_folder=<span class="string">&#x27;../templates&#x27;</span>, 和 static_folder=<span class="string">&quot;../static&quot;</span>, static_url_path=<span class="string">&quot;/static&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="现在我们知道第一个参数的意义，那我们可以直接这样写就可以了"><a href="#现在我们知道第一个参数的意义，那我们可以直接这样写就可以了" class="headerlink" title="现在我们知道第一个参数的意义，那我们可以直接这样写就可以了"></a>现在我们知道第一个参数的意义，那我们可以直接这样写就可以了</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(__name__)</span><br><span class="line">app = Flask(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">print(app.root_path)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">config.config</span></span><br><span class="line"><span class="string">I:\libaibuaidufu\app</span></span><br><span class="line"><span class="string">此时的app，root_path 就是对的。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>grpc 之 word2pdf使用</title>
    <url>/post/grpc-%E4%B9%8B-word2pdf%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<blockquote>
<pre><code>    做一个word转pdf的服务，采用grpc，使用libreoffice命令。</code></pre>
</blockquote>
<a id="more"></a>

<h2 id="构建libreoffice镜像"><a href="#构建libreoffice镜像" class="headerlink" title="构建libreoffice镜像"></a>构建libreoffice镜像</h2><ol>
<li>采用python3.6镜像 </li>
<li>使用阿里源</li>
<li>安装libreoffice</li>
<li>解决中文乱码 加入中文字体</li>
</ol>
<h3 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /etc/apt \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mv sources.list sources.list.bak \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;deb http://mirrors.aliyun.com/debian/ stretch main non-free contrib \</span></span></span><br><span class="line"><span class="bash">deb-src http://mirrors.aliyun.com/debian/ stretch main non-free contrib \</span></span><br><span class="line"><span class="bash">deb http://mirrors.aliyun.com/debian-security stretch/updates main \</span></span><br><span class="line"><span class="bash">deb-src http://mirrors.aliyun.com/debian-security stretch/updates main \</span></span><br><span class="line"><span class="bash">deb http://mirrors.aliyun.com/debian/ stretch-updates main non-free contrib \</span></span><br><span class="line"><span class="bash">deb-src http://mirrors.aliyun.com/debian/ stretch-updates main non-free contrib \</span></span><br><span class="line"><span class="bash">deb http://mirrors.aliyun.com/debian/ stretch-backports main non-free contrib \</span></span><br><span class="line"><span class="bash">deb-src http://mirrors.aliyun.com/debian/ stretch-backports main non-free contrib<span class="string">&quot; &gt; sources.list</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y libreoffice</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./ /root/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mv /root/simsun.ttc /usr/share/fonts &amp;&amp; mv /root/simhei.ttf /usr/share/fonts &amp;&amp; <span class="built_in">cd</span> /usr/share/fonts &amp;&amp; <span class="built_in">fc</span>-cache -fv</span></span><br><span class="line"><span class="comment"># docker build -t libreoffice .</span></span><br></pre></td></tr></table></figure>

<h2 id="grpc服务端、客户端"><a href="#grpc服务端、客户端" class="headerlink" title="grpc服务端、客户端"></a>grpc服务端、客户端</h2><ol>
<li><p>创建proto配置文件 然后编译</p>
</li>
<li><p>服务端与客户端 采用二进制  数据进行传输</p>
</li>
</ol>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/7/9 0009 16:41</span></span><br><span class="line"><span class="comment"># @File    : word2pdf_server_main.py</span></span><br><span class="line"><span class="comment"># @author  : dfkai</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. ./data.proto</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> proto_py <span class="keyword">import</span> word2pdf_pb2, word2pdf_pb2_grpc</span><br><span class="line"></span><br><span class="line">_ONE_DAY_IN_SECONDS = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span></span><br><span class="line">_HOST = os.environ.get(<span class="string">&quot;HOSTNAME&quot;</span>, <span class="string">&quot;localhost&quot;</span>)</span><br><span class="line">_PORT = <span class="string">&#x27;8080&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormatData</span>(<span class="params">word2pdf_pb2_grpc.FormatDataServicer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DoFormat</span>(<span class="params">self, request, context</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        proto 定义方法</span></span><br><span class="line"><span class="string">        :param request:</span></span><br><span class="line"><span class="string">        :param context:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        data = request.text</span><br><span class="line">        doc_path, pdf_path, pdf_file_path = self.get_doc_pdf_path()</span><br><span class="line">        <span class="keyword">with</span> open(doc_path, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(data)</span><br><span class="line">        <span class="keyword">if</span> self.word2pdf_linux(doc_path, pdf_path):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">with</span> open(pdf_file_path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    pdf_data = f.read()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                traceback.format_exc()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pdf_data = <span class="string">b&quot;fail&quot;</span></span><br><span class="line">        <span class="keyword">return</span> word2pdf_pb2.Data(text=pdf_data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_doc_pdf_path</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        获取文件路径</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        baseDir = os.getcwd()</span><br><span class="line">        p = pathlib.Path(baseDir)</span><br><span class="line">        u_name = str(uuid.uuid4()).replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        doc_name = u_name + <span class="string">&quot;.docx&quot;</span></span><br><span class="line">        pdf_name = u_name + <span class="string">&quot;.pdf&quot;</span></span><br><span class="line">        pdf_path = p / <span class="string">f&quot;filepath/pdf/&quot;</span></span><br><span class="line">        doc_path = p / <span class="string">f&quot;filepath/doc/<span class="subst">&#123;doc_name&#125;</span>&quot;</span></span><br><span class="line">        pdf_file_path = p / <span class="string">f&quot;filepath/pdf/<span class="subst">&#123;pdf_name&#125;</span>&quot;</span></span><br><span class="line">        print(doc_path, pdf_path, pdf_file_path)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">rf&quot;<span class="subst">&#123;doc_path&#125;</span>&quot;</span>, <span class="string">rf&quot;<span class="subst">&#123;pdf_path&#125;</span>&quot;</span>, <span class="string">rf&quot;<span class="subst">&#123;pdf_file_path&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">word2pdf_win</span>(<span class="params">self, doc_path, pdf_path</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        windows 生成</span></span><br><span class="line"><span class="string">        :param doc_path:</span></span><br><span class="line"><span class="string">        :param pdf_path:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">from</span> win32com <span class="keyword">import</span> client</span><br><span class="line">        <span class="keyword">import</span> pythoncom</span><br><span class="line">        pythoncom.CoInitialize()</span><br><span class="line">        <span class="comment"># word = client.Dispatch(&quot;Word.Application&quot;)</span></span><br><span class="line">        word = client.DispatchEx(<span class="string">&quot;Word.Application&quot;</span>)</span><br><span class="line">        worddoc = word.Documents.Open(doc_path)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            worddoc.SaveAs(pdf_path, FileFormat=<span class="number">17</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            worddoc.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">word2pdf_linux</span>(<span class="params">self, doc_path, pdf_path</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        linux 生成 pdf ,利用 libreoffice 命令</span></span><br><span class="line"><span class="string">        :param doc_path:</span></span><br><span class="line"><span class="string">        :param pdf_path:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            os.system(<span class="string">f&quot;soffice --headless --invisible --convert-to pdf <span class="subst">&#123;doc_path&#125;</span> --outdir <span class="subst">&#123;pdf_path&#125;</span> &quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            traceback.format_exc()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serve</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    rpc 服务</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    grpcServer = grpc.server(futures.ThreadPoolExecutor(max_workers=<span class="number">4</span>))</span><br><span class="line">    word2pdf_pb2_grpc.add_FormatDataServicer_to_server(FormatData(), grpcServer)</span><br><span class="line">    grpcServer.add_insecure_port(_HOST + <span class="string">&#x27;:&#x27;</span> + _PORT)</span><br><span class="line">    grpcServer.start()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(_ONE_DAY_IN_SECONDS)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        grpcServer.stop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    serve()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/7/9 0009 16:40</span></span><br><span class="line"><span class="comment"># @File    : word2pdf_client_main.py</span></span><br><span class="line"><span class="comment"># @author  : dfkai</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">from</span> proto_py <span class="keyword">import</span> word2pdf_pb2, word2pdf_pb2_grpc</span><br><span class="line"></span><br><span class="line">_HOST = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">_PORT = <span class="string">&#x27;8080&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    file_name = <span class="string">&quot;test&quot;</span></span><br><span class="line">    doc_name = file_name + <span class="string">&#x27;.doc&#x27;</span></span><br><span class="line">    conn = grpc.insecure_channel(_HOST + <span class="string">&#x27;:&#x27;</span> + _PORT)</span><br><span class="line">    client = word2pdf_pb2_grpc.FormatDataStub(channel=conn)</span><br><span class="line">    <span class="keyword">with</span> open(doc_name, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    response = client.DoFormat(word2pdf_pb2.Data(text=data))</span><br><span class="line">    <span class="keyword">if</span> response.text == <span class="string">b&quot;fail&quot;</span>:</span><br><span class="line">        <span class="comment"># 发送消息 生成失败</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pdf_name = file_name + <span class="string">f&#x27;.pdf&#x27;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> open(pdf_name, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(response.text)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            traceback.format_exc()</span><br><span class="line">            <span class="comment"># 发送消息 生成失败</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 发送消息 生成成功</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    beg = time.time()</span><br><span class="line">    run()</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(end - beg)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="proto配置文件"><a href="#proto配置文件" class="headerlink" title="proto配置文件"></a>proto配置文件</h3><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">FormatData</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> DoFormat(Data) <span class="keyword">returns</span> (Data)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">  <span class="built_in">bytes</span> text = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入文件目录，构建命令：python -m grpc_tools.protoc -I. –python_out=./proto_py/ –grpc_python_out=./proto_py/ ./proto/word2pdf.proto</p>
<h2 id="构建rpc服务端镜像"><a href="#构建rpc服务端镜像" class="headerlink" title="构建rpc服务端镜像"></a>构建rpc服务端镜像</h2><h3 id="dockerfile-1"><a href="#dockerfile-1" class="headerlink" title="dockerfile"></a>dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> libreoffice</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./ /root/</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root/word2pdfRPC</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install -i https://mirrors.aliyun.com/pypi/simple/ -r requirments.txt</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> python server_main.py</span></span><br><span class="line"><span class="comment"># docker build -t word2pdf .</span></span><br><span class="line"><span class="comment"># docker run -d -p 8080:8080 -v /root/data/word2pdf/:/root/word2pdfRPC/filepath/ --name word2pdf word2pdf</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="reuirements-txt"><a href="#reuirements-txt" class="headerlink" title="reuirements.txt"></a>reuirements.txt</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">futures&#x3D;&#x3D;3.1.1</span><br><span class="line">grpcio&#x3D;&#x3D;1.22.0</span><br><span class="line">grpcio-tools&#x3D;&#x3D;1.22.0</span><br><span class="line">protobuf&#x3D;&#x3D;3.8.0</span><br></pre></td></tr></table></figure>



<p>参考、推荐:</p>
<ol>
<li><a href="https://blog.csdn.net/xqy1522/article/details/6942344">protobuf和thrift对比</a></li>
<li><a href="https://developers.google.com/protocol-buffers/docs/proto3">Language Guide (proto3)</a></li>
<li><a href="https://developers.google.com/protocol-buffers/docs/encoding">Encoding</a></li>
</ol>
]]></content>
      <categories>
        <category>代码来了</category>
      </categories>
      <tags>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>github actions 自动部署 hexo</title>
    <url>/post/github-actions-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-hexo.html</url>
    <content><![CDATA[<p>github actions 自动部署 hexo,感觉还是有点问题。有很多方法可以解决，但是我这里就不折腾了。</p>
<a id="more"></a>

<p>我自己的提问：<a href="https://github.com/JamesIves/github-pages-deploy-action/issues/389">https://github.com/JamesIves/github-pages-deploy-action/issues/389</a></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>hexo 安装 需要全局，但是没有权限无法安装。可以利用docker安装 ，解决权限问题。</p>
<p>但是新版本的 action，作者去掉了docker，鼓励本地直接构建，然后直接同步。</p>
<p><strong>而且同步到其他仓库的功能在新的版本里才可以使用</strong></p>
<p>最后我已使用了本地构建这个方案。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">buildAndDeploy</span></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">checkout</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">          <span class="attr">persist-credentials:</span> <span class="literal">false</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@3.5.9</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">ACCESS_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ACCESS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">REPOSITORY_NAME:</span> <span class="string">libaibuaidufu/libaibuaidufu.github.io</span></span><br><span class="line">        <span class="attr">BRANCH:</span> <span class="string">master</span> </span><br><span class="line">        <span class="attr">BASE_BRANCH:</span> <span class="string">master</span> </span><br><span class="line">        <span class="attr">FOLDER:</span> <span class="string">public</span> </span><br></pre></td></tr></table></figure>

<h3 id="骚操作"><a href="#骚操作" class="headerlink" title="骚操作"></a>骚操作</h3><p>中途我也想了骚操作，例如用以前的版本，来构建，再用新的版本来部署。最后出现了权限问题。就没有继续了。</p>
<p><strong>因为同步到其他仓库的功能在新的版本里才可以使用</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">buildAndDeploy</span></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">checkout</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">          <span class="attr">persist-credentials:</span> <span class="literal">false</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">build</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@releases/v2</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">ACCESS_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ACCESS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">REPOSITORY_NAME:</span> <span class="string">libaibuaidufu/libaibuaidufu/private-blog-deploy-actions</span></span><br><span class="line">        <span class="attr">BASE_BRANCH:</span> <span class="string">master</span></span><br><span class="line">        <span class="attr">BRANCH:</span> <span class="string">gh-pages</span></span><br><span class="line">        <span class="attr">FOLDER:</span> <span class="string">public</span></span><br><span class="line">        <span class="attr">BUILD_SCRIPT:</span>  <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">&amp;&amp;</span> <span class="string">hexo</span> <span class="string">clean</span> <span class="string">&amp;&amp;</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@3.5.9</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">ACCESS_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ACCESS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">REPOSITORY_NAME:</span> <span class="string">libaibuaidufu/libaibuaidufu.github.io</span></span><br><span class="line">        <span class="attr">BRANCH:</span> <span class="string">master</span> </span><br><span class="line">        <span class="attr">BASE_BRANCH:</span> <span class="string">master</span> </span><br><span class="line">        <span class="attr">FOLDER:</span> <span class="string">public</span> </span><br></pre></td></tr></table></figure>

<h3 id="windows-bat-命令"><a href="#windows-bat-命令" class="headerlink" title="windows bat 命令"></a>windows bat 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cls</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span> 清理中。。。</span><br><span class="line">call hexo clean </span><br><span class="line"><span class="built_in">echo</span> 重新构建。。。</span><br><span class="line">call hexo g </span><br><span class="line"><span class="built_in">echo</span> 添加新的修改。。。</span><br><span class="line">call git add . </span><br><span class="line"><span class="built_in">set</span> /p commit_message=提交内容：</span><br><span class="line"><span class="built_in">echo</span> 提交新的修改</span><br><span class="line">call git commit -m %commit_message%</span><br><span class="line"><span class="built_in">echo</span> 推送新的修改</span><br><span class="line">call git push -u origin master</span><br><span class="line"><span class="built_in">echo</span> 已完成</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github-action</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo next主题 安装记录</title>
    <url>/post/install-next-all.html</url>
    <content><![CDATA[<p>最近无聊有想整点东西，想这写blog，就心血来潮又搞了hexo，想着这次一定要静下心来。</p>
<a id="more"></a>

<h3 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g --registry=https://registry.npm.taobao.org</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<h3 id="根据配置-修改自己的信息"><a href="#根据配置-修改自己的信息" class="headerlink" title="根据配置 修改自己的信息"></a>根据配置 修改自己的信息</h3><p>官网：<a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a></p>
<h3 id="安装主题-next"><a href="#安装主题-next" class="headerlink" title="安装主题 next"></a>安装主题 next</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h3 id="修改-主题配置"><a href="#修改-主题配置" class="headerlink" title="修改 主题配置"></a>修改 主题配置</h3><p>官网：<a href="https://theme-next.iissnan.com/getting-started.html">https://theme-next.iissnan.com/getting-started.html</a></p>
<h3 id="集成第三方插件"><a href="#集成第三方插件" class="headerlink" title="集成第三方插件"></a>集成第三方插件</h3><h4 id="1-搜索"><a href="#1-搜索" class="headerlink" title="1.搜索"></a>1.搜索</h4><h5 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h5 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h5><p>安装完成，编辑博客配置文件：<code>_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<h5 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h5><p>Next 主题自带搜索设置，编辑主题配置文件：<code>_config.yml</code></p>
<p>找到文件中 Local search 的相关配置，设为 <code>true</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<h4 id="2-评论和阅读次数"><a href="#2-评论和阅读次数" class="headerlink" title="2.评论和阅读次数"></a>2.评论和阅读次数</h4><p>注册 learncloud 进行部署</p>
<h4 id="3-seo优化"><a href="#3-seo优化" class="headerlink" title="3.seo优化"></a>3.seo优化</h4><p>参考：[<a href="https://hoxis.github.io/Hexo+Next%20SEO%E4%BC%98%E5%8C%96.html]">https://hoxis.github.io/Hexo+Next%20SEO%E4%BC%98%E5%8C%96.html]</a>(<a href="https://hoxis.github.io/Hexo+Next">https://hoxis.github.io/Hexo+Next</a> SEO优化.html)</p>
<h5 id="安装插件-1"><a href="#安装插件-1" class="headerlink" title="安装插件"></a>安装插件</h5><p>需要安装两个插件来生成 sitemap 文件，前一个是传统的 sitemap，后一个是百度的 sitemap。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>

<h4 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h4><p>将<code>sitemap</code>文件添加到站点配置文件<code>_config.yml</code>中，并修改<code>url</code>字段的值，其值默认为<code>http://yoursite.com</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sitemap:</span> </span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://libaibuaidufu.club</span> <span class="comment"># 这个在最开始的地方有 注意重复</span></span><br></pre></td></tr></table></figure>

<h4 id="rabots-协议"><a href="#rabots-协议" class="headerlink" title="rabots 协议"></a>rabots 协议</h4><p>在站点<code>source</code>文件夹下新建<code>robots.txt</code>文件，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: &#x2F;</span><br><span class="line">Allow: &#x2F;archives&#x2F;</span><br><span class="line">Allow: &#x2F;categories&#x2F;</span><br><span class="line">Allow: &#x2F;tags&#x2F; </span><br><span class="line">Allow: &#x2F;resources&#x2F; </span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;js&#x2F;</span><br><span class="line">Disallow: &#x2F;css&#x2F;</span><br><span class="line">Disallow: &#x2F;fonts&#x2F;</span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;fancybox&#x2F;</span><br><span class="line"></span><br><span class="line">Sitemap: https:&#x2F;&#x2F;libaibuaidufu.club&#x2F;sitemap.xml</span><br><span class="line">Sitemap: https:&#x2F;&#x2F;libaibuaidufu.club&#x2F;baidusitemap.xml</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>安装完成后执行<code>hexo g</code>即会在站点<code>public</code>目录下生成<code>sitemap.xml</code>和<code>baidusitemap.xml</code>。</p>
<p><code>Allow</code>字段的值即为允许搜索引擎爬区的内容，可以对应到主题配置文件中的menu目录配置，如果菜单栏还有其他选项都可以按照格式自行添加。</p>
<p>需要将<code>https://hoxis.github.io</code>改成自己的域名。</p>
<h3 id="github部署"><a href="#github部署" class="headerlink" title="github部署"></a>github部署</h3><p>github：<a href="https://hexo.io/zh-cn/docs/github-pages">https://hexo.io/zh-cn/docs/github-pages</a></p>
<p>一键部署：<a href="https://hexo.io/zh-cn/docs/one-command-deployment">https://hexo.io/zh-cn/docs/one-command-deployment</a></p>
<p>安装插件：<code>npm install hexo-deployer-git --save --registry=https://registry.npm.taobao.org</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/&lt;username&gt;/&lt;project&gt;</span></span><br><span class="line">  <span class="comment"># example, https://github.com/hexojs/hexojs.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>selenium 反爬虫识别特征处理</title>
    <url>/post/selenium-%E5%8F%8D%E7%88%AC%E8%99%AB%E8%AF%86%E5%88%AB%E7%89%B9%E5%BE%81%E5%A4%84%E7%90%86.html</url>
    <content><![CDATA[<p><strong>因为业务中发现网站对selenium特征识别为爬虫了，因此在搜索引擎中搜索进行处理</strong></p>
<a id="more"></a>

<h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实例化一个浏览器对象</span></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line"><span class="keyword">if</span> sys.platform == <span class="string">&quot;win32&quot;</span>:</span><br><span class="line">    browser = webdriver.Chrome(driver_path, options=options)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    browser = webdriver.Chrome(options=options)</span><br><span class="line">browser.implicitly_wait(<span class="number">30</span>)</span><br><span class="line">browser.execute_cdp_cmd(<span class="string">&quot;Page.addScriptToEvaluateOnNewDocument&quot;</span>, &#123;</span><br><span class="line">    <span class="string">&quot;source&quot;</span>: <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Object.defineProperty(navigator, &#x27;webdriver&#x27;, &#123;</span></span><br><span class="line"><span class="string">      get: () =&gt; undefined</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此方法虽然可以躲避识别，但是在使用过一段时候后，依然出现被屏蔽的问题。</p>
<p>因此只有继续搜索 然后再stackoverflow 中又找到了新的答案。</p>
<h3 id="方式二-（推荐）"><a href="#方式二-（推荐）" class="headerlink" title="方式二 （推荐）"></a>方式二 （推荐）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实例化一个浏览器对象</span></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_argument(<span class="string">&quot;--disable-blink-features=AutomationControlled&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> sys.platform == <span class="string">&quot;win32&quot;</span>:</span><br><span class="line">    browser = webdriver.Chrome(driver_path, options=options)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    browser = webdriver.Chrome(options=options)</span><br></pre></td></tr></table></figure>

<p>这个方法执行的后，目前运行良好也没有出现被识别的问题。</p>
<h3 id="关闭当前标签-在切换标签前关闭"><a href="#关闭当前标签-在切换标签前关闭" class="headerlink" title="关闭当前标签 在切换标签前关闭"></a>关闭当前标签 在切换标签前关闭</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.close()</span><br><span class="line">windows = driver.window_handles</span><br><span class="line">driver.switch_to.window(windows[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>代码来了</category>
      </categories>
      <tags>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl 定时任务 crontab权限</title>
    <url>/post/wsl-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-crontab%E6%9D%83%E9%99%90.html</url>
    <content><![CDATA[<p>可能有一些乱,但是不影响整体思路。</p>
<h3 id="安装-wsl"><a href="#安装-wsl" class="headerlink" title="安装 wsl"></a>安装 wsl</h3><p>首先在windows上 打开 <strong>启动或关闭windows功能</strong>  选择 <strong>适用于 Linux 的 windows 子系统</strong> 打勾</p>
<p>然后取 windows应用市场 搜索 wsl ，下载你喜欢的一个 linux子系统</p>
<p>我这边安装了一个 debian，一个ubuntu。</p>
<p>如果你没有开启<strong>适用于 Linux 的 windows 子系统</strong> 是无法安装的。</p>
<p><strong>记得一定要安装windows terminal 这个太提升体验了</strong></p>
<a id="more"></a>

<h3 id="配置linux子系统"><a href="#配置linux子系统" class="headerlink" title="配置linux子系统"></a>配置linux子系统</h3><p>进入 debian系统</p>
<h4 id="挂载windows和linux的共享盘"><a href="#挂载windows和linux的共享盘" class="headerlink" title="挂载windows和linux的共享盘"></a>挂载windows和linux的共享盘</h4><p>可以先在linux子系统和windows之间建立一个共享盘</p>
<p>挂载 windows D盘的wsl_linux 到 debian到 win10目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /mnt/d/wsl_linux ~/win10 </span><br></pre></td></tr></table></figure>

<h4 id="换国内源"><a href="#换国内源" class="headerlink" title="换国内源"></a>换国内源</h4><p>清华源地址:<a href="https://mirrors.tuna.tsinghua.edu.cn/help/debian/">https://mirrors.tuna.tsinghua.edu.cn/help/debian/</a></p>
<p><strong>这是debian10</strong></p>
<p>在windows中 创建一个 sources.list ,同样也可以在linux下创建，看你喜欢</p>
<p>把内容直接复制到sources.list 里面，因为无法拉去 https ，所以可以吧所有的https改为http</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;debian&#x2F; buster main contrib non-free</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;debian&#x2F; buster-updates main contrib non-free</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;debian&#x2F; buster-backports main contrib non-free</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;debian-security buster&#x2F;updates main contrib non-free</span><br></pre></td></tr></table></figure>

<p>然后把 文件复制到 /etc/apt中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo cp ~/win10/sources.list /etc/apt/sources.list</span><br><span class="line">sudo apt update</span><br><span class="line"><span class="comment">#安装 ca证书 就可以拉去 https</span></span><br><span class="line">sudo apt install apt-transport-https ca-certificates</span><br><span class="line"><span class="comment">#此时就可以修改所有http为 https了</span></span><br><span class="line"><span class="comment"># 然后在执行一次</span></span><br><span class="line">sudo apt update</span><br><span class="line"><span class="comment"># 安装一些我需要的软件</span></span><br><span class="line">sudo apt install crul wget vim -y</span><br></pre></td></tr></table></figure>

<p>此时debian的系统就调试的差不多了。</p>
<h3 id="设置定时任务-crontab-及其权限"><a href="#设置定时任务-crontab-及其权限" class="headerlink" title="设置定时任务 crontab 及其权限"></a>设置定时任务 crontab 及其权限</h3><p>设置定时任务 crontab  ，因为crontab定时任务的命令网上太多了一搜一大堆，我这里就不复制，粘贴了。</p>
<h4 id="编辑定时任务"><a href="#编辑定时任务" class="headerlink" title="编辑定时任务"></a>编辑定时任务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一次 他需要让你选择打开使用的编辑器 选择 vim就好了 或者 选择自己熟悉的</span></span><br><span class="line">crontab -e</span><br><span class="line">0 21 * * * <span class="built_in">cd</span> /home/libai/fping-4.2/src/ &amp;&amp; sudo /bin/bash /home/libai/fping-4.2/src/cf.sh &gt;&gt; /var/<span class="built_in">log</span>/cf_log.log</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">crontab -l</span><br><span class="line"><span class="comment"># 重启 这样才会设置任务 ### 认识错误 不用重启  他会自己去读取</span></span><br><span class="line">sudo service cron restart <span class="comment"># debian</span></span><br><span class="line">sudo systemctl restart crond.service <span class="comment"># centos</span></span><br></pre></td></tr></table></figure>

<p>我的这个任务是每天晚上九点 执行一次。</p>
<p>因为执行命令需要root权限。我们需要设置执行我们这个命令时候，不需要输入密码。</p>
<h4 id="设置-visudo-，定时任务权限"><a href="#设置-visudo-，定时任务权限" class="headerlink" title="设置 visudo ，定时任务权限"></a>设置 visudo ，定时任务权限</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开 visudo</span></span><br><span class="line">sudo visudo</span><br><span class="line"><span class="comment"># 在末尾添加 这个用的是nano编辑器</span></span><br><span class="line">%sudo ALL=NOPASSWD: /etc/init.d/cron start</span><br><span class="line">%sudo ALL=NOPASSWD: /bin/bash /home/libai/fping-4.2/src/cf.sh</span><br><span class="line"><span class="comment"># 这里的命令要和上面crontab -e 命令保持一致 路径也一样 不然还是要输入密码的</span></span><br><span class="line"><span class="comment"># 路径 和 目录写清楚 可从下面参考里面看详细的visudo命令解释</span></span><br><span class="line"><span class="comment"># who     where=(whom)    commands</span></span><br><span class="line"><span class="comment"># 用户    主机=（以谁的身份） commands</span></span><br><span class="line"><span class="comment"># nano 命令</span></span><br><span class="line"><span class="comment"># 保存</span></span><br><span class="line">Ctrl+O 然后回车一下就可以了</span><br><span class="line"><span class="comment"># 推出</span></span><br><span class="line">Ctrl+X</span><br></pre></td></tr></table></figure>

<p>此时定时任务就可以起飞了，同时把任务日志保存一下，看看是不是真的运行了。同时运行有什么问题，也可以处理。** &gt;&gt; /var/log/cf_log.log** 注意创建此文件同时注意权限 <strong>chmod 777 cf_log.log</strong></p>
<h3 id="关闭linux子系统，windows开机启动"><a href="#关闭linux子系统，windows开机启动" class="headerlink" title="关闭linux子系统，windows开机启动"></a>关闭linux子系统，windows开机启动</h3><p>但是这样当我们关闭windows子系统的时候，整个就关闭了，就没有什么定时任务了，因此我们要创建一个windows的开启任务。</p>
<p>在windows下：</p>
<p>win+R 输入 shell:startup 打开目录</p>
<p>新建一个 快捷方式</p>
<p>输入 <strong>C:\Windows\System32\wsl.exe sudo /etc/init.d/cron start</strong> </p>
<p>你发现这个命令和我们上面visudo的添加第一个命令一致，但是我开机启动时，还是要让我输入密码。。。</p>
<p><strong>需要输入密码是因为wsl默认启动我的ubuntu，修改默认启动顺序，如果你只有一个系统就不会出现这个情况或者你用的系统是你第一个安装应该也是没有问题的</strong></p>
<h4 id="查看、修改默认系统"><a href="#查看、修改默认系统" class="headerlink" title="查看、修改默认系统"></a>查看、修改默认系统</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\dfk&gt; wslconfig /list</span><br><span class="line">适用于 Linux 的 Windows 子系统:</span><br><span class="line">Ubuntu<span class="literal">-20</span>.<span class="number">04</span> (默认)</span><br><span class="line">Debian</span><br><span class="line"><span class="built_in">PS</span> C:\Users\dfk&gt; wslconfig /s Debian <span class="comment"># 修改默认</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\dfk&gt; wsl <span class="comment"># 进入系统</span></span><br><span class="line">libai@DESKTOP<span class="literal">-3SJEOBV</span>:/mnt/c/Users/dfk<span class="variable">$</span> uname <span class="literal">-a</span> <span class="comment"># 查看是否是 debian</span></span><br><span class="line">Linux DESKTOP<span class="literal">-3SJEOBV</span> <span class="number">4.4</span>.<span class="number">0</span><span class="literal">-18362</span><span class="literal">-Microsoft</span> <span class="comment">#836-Microsoft Mon May 05 16:04:00 PST 2020 x86_64 GNU/Linux</span></span><br><span class="line">libai@DESKTOP<span class="literal">-3SJEOBV</span>:/mnt/c/Users/dfk<span class="variable">$</span> <span class="built_in">cat</span> /etc/issue</span><br><span class="line">Debian GNU/Linux <span class="number">10</span> \n \l</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>命令帮助：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">对 Windows 上的 Linux 子系统进行操作管理</span><br><span class="line"></span><br><span class="line">用途：</span><br><span class="line">    /l, /list [/all]</span><br><span class="line">        列出已注册的分发版。</span><br><span class="line">        /all - 有选择地列出所有分发版，包括</span><br><span class="line">               当前正在安装或卸载的分发版。</span><br><span class="line"></span><br><span class="line">    /s, /setdefault &lt;DistributionName&gt;</span><br><span class="line">        将该分发版设为默认。</span><br><span class="line"></span><br><span class="line">    /t, /terminate &lt;DistributionName&gt;</span><br><span class="line">        终止分发。</span><br><span class="line"></span><br><span class="line">    /u, /unregister &lt;DistributionName&gt;</span><br><span class="line">        取消分发版注册。</span><br><span class="line"></span><br><span class="line">    /upgrade &lt;DistributionName&gt;</span><br><span class="line">        将分发版升级至 WslFs 文件系统格式。</span><br></pre></td></tr></table></figure>

<h4 id="最后再次执行-快捷方式-看看-要不要密码"><a href="#最后再次执行-快捷方式-看看-要不要密码" class="headerlink" title="最后再次执行 快捷方式 看看 要不要密码"></a>最后再次执行 快捷方式 看看 要不要密码</h4><p>不要了 完美了。。。。。。</p>
<h4 id="查看windows是否开启"><a href="#查看windows是否开启" class="headerlink" title="查看windows是否开启"></a>查看windows是否开启</h4><p>查看 任务管理系统，里面有没有一个cron的进程，有就是成功了的。</p>
<p>参考：</p>
<ol>
<li><a href="https://www.jianshu.com/p/fff3ccc3e04e">sudo和它的编辑工具visudo</a></li>
<li><a href="%5Bhttps://naizi.moe/2020/01/24/wsl-crontab/#%E5%AE%89%E8%A3%85WSL%5D(https://naizi.moe/2020/01/24/wsl-crontab/#%E5%AE%89%E8%A3%85WSL)">Windows使用WSL配置crontab定时任务</a></li>
<li><a href="https://sxi.io/how-to-start-stop-restart-cron-service-in-linux-centos-7/">How To Start/Stop/Restart Cron Service In Linux Centos 7</a></li>
</ol>
]]></content>
      <categories>
        <category>wsl</category>
      </categories>
      <tags>
        <tag>wsl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy+scrapyd 部署使用</title>
    <url>/post/scrapy-scrapyd-%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<h3 id="scrapyd-部署"><a href="#scrapyd-部署" class="headerlink" title="scrapyd 部署"></a>scrapyd 部署</h3><p><strong>注</strong>：example 为项目名称</p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install scrapyd <span class="comment"># 快速部署爬虫 服务端</span></span><br><span class="line">pip install scrapyd-client <span class="comment"># 快速部署爬虫 客户端</span></span><br><span class="line">pip install scrapyd-api <span class="comment"># 集成python可调用api</span></span><br><span class="line">pip install scrapydweb <span class="comment"># web页面</span></span><br><span class="line">pip install logparser <span class="comment"># 日志解析</span></span><br></pre></td></tr></table></figure>

<h5 id="启动-scrapyd"><a href="#启动-scrapyd" class="headerlink" title="启动 scrapyd"></a>启动 scrapyd</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrapyd -p example</span><br></pre></td></tr></table></figure>

<h5 id="部署-爬虫"><a href="#部署-爬虫" class="headerlink" title="部署 爬虫"></a>部署 爬虫</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrapyd-deploy -p example</span><br><span class="line"></span><br><span class="line">scrapyd-deploy &lt;target&gt; -p example</span><br></pre></td></tr></table></figure>

<h5 id="添加爬虫"><a href="#添加爬虫" class="headerlink" title="添加爬虫"></a>添加爬虫</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:6800/schedule.json -d project=example -d spider=dongtan</span><br></pre></td></tr></table></figure>

<h5 id="取消爬虫"><a href="#取消爬虫" class="headerlink" title="取消爬虫"></a>取消爬虫</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:6800/cancel.json -d project=example -d job=68d25db0506111e9a4c0e2df1c2eb35b</span><br><span class="line"><span class="comment"># job 为可在web查看</span></span><br></pre></td></tr></table></figure>

<h5 id="启动scrapyweb"><a href="#启动scrapyweb" class="headerlink" title="启动scrapyweb"></a>启动scrapyweb</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一次运行 一下命令 生成一个配置文件 scrapydweb_settings_v10.py</span></span><br><span class="line">scrapydweb </span><br><span class="line"><span class="comment"># 第二次运行 则进行运行 同目录下</span></span><br><span class="line">scrapydweb </span><br></pre></td></tr></table></figure>

<h5 id="启动logparser"><a href="#启动logparser" class="headerlink" title="启动logparser"></a>启动logparser</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 scrapydweb_settings_v10.py 一下为Ture 会自动生成 stats.json 在日志目录下，可以重启一下scrapydweb</span></span><br><span class="line">ENABLE_LOGPARSER = True</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后运行 就可以了</span></span><br><span class="line">logparser </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="scrapy-cfg"><a href="#scrapy-cfg" class="headerlink" title="scrapy.cfg"></a>scrapy.cfg</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">settings</span>]</span><br><span class="line"><span class="string">default</span> <span class="string">=</span> <span class="string">example.settings</span></span><br><span class="line">[<span class="string">deploy</span>]</span><br><span class="line"><span class="string">url</span> <span class="string">=</span> <span class="string">http://localhost:6800/</span></span><br><span class="line"><span class="string">project</span> <span class="string">=</span> <span class="string">example</span></span><br><span class="line">[<span class="string">deploy:djwq</span>]</span><br><span class="line"><span class="string">url</span> <span class="string">=</span> <span class="string">http://localhost:2100/</span></span><br><span class="line"><span class="string">project</span> <span class="string">=</span> <span class="string">example</span></span><br><span class="line"><span class="comment"># scrapyd-deploy -p example</span></span><br><span class="line"><span class="comment"># scrapyd-deploy djwq -p example</span></span><br></pre></td></tr></table></figure>



<p>源码地址：<a href="https://github.com/libaibuaidufu/scrapyd_web_log">https://github.com/libaibuaidufu/scrapyd_web_log</a></p>
]]></content>
      <categories>
        <category>代码来了</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
        <tag>scrapyd</tag>
      </tags>
  </entry>
  <entry>
    <title>Android逆向流程</title>
    <url>/post/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E6%B5%81%E7%A8%8B.html</url>
    <content><![CDATA[<p>工具地址：</p>
<ol>
<li>kstools <a href="https://github.com/fourbrother/kstools">https://github.com/fourbrother/kstools</a></li>
<li>52爱盘工具 <a href="https://down.52pojie.cn/Tools/Android_Tools/">https://down.52pojie.cn/Tools/Android_Tools/</a></li>
<li>AndroidKiller (下面同理都在爱盘里面有)</li>
<li>apkIDE</li>
<li>apktools</li>
<li>dex2jar</li>
<li>jadx</li>
<li>jd-gui</li>
</ol>
<a id="more"></a>

<h3 id="kstools-爆破-签名校验"><a href="#kstools-爆破-签名校验" class="headerlink" title="kstools 爆破 签名校验"></a>kstools 爆破 签名校验</h3><p>有一些程序有签名的校验，当你修改完，打包的时候后，可以安装，但是打开闪退，或者弹出提示框，大部分就是有签名校验。</p>
<p>下载kstools工具，没有加固的就使用kstools.bat,直接搞定。注意appt的配置，我是用的apkIDE里面的appt。</p>
<h3 id="AndroidKiller-集成软件"><a href="#AndroidKiller-集成软件" class="headerlink" title="AndroidKiller 集成软件"></a>AndroidKiller 集成软件</h3><p>AndroidKiller  集成了常用的软件，配上可视化操作，十分好上手，就是里面的插件有点久了，需要自己手动替换为爱盘里面的最新版插件。</p>
<ol>
<li>配置java环境，配置最新版的apktools.</li>
<li>把爆破签名后生成的apk，拖进去，可自己动反编译。</li>
<li>如果未修改签名，有一些app无法编译成功，会在编译死，需要关闭再次打开才可以，最好先爆破一下</li>
<li>修改smail文件，保存</li>
<li>编译，然后连接手机，安装</li>
<li>测试是否可用</li>
</ol>
<h3 id="单独使用工具"><a href="#单独使用工具" class="headerlink" title="单独使用工具"></a>单独使用工具</h3><h4 id="apktools-资源编译"><a href="#apktools-资源编译" class="headerlink" title="apktools 资源编译"></a>apktools 资源编译</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar apktool_2.3.1.jar d -f KeyValueTest.apk -o KeyValueTest</span><br><span class="line">参数说明：</span><br><span class="line">-f 如果目标文件夹已存在，则强制删除现有文件夹（默认如果目标文件夹已存在，则解码失败）。</span><br><span class="line">-o 指定解码目标文件夹的名称（默认使用APK文件的名字来命名目标文件夹）。</span><br><span class="line">-s 不反编译dex文件，也就是说classes.dex文件会被保留（默认会将dex文件解码成smali文件）。</span><br><span class="line">-r 不反编译资源文件，也就是说resources.arsc文件会被保留（默认会将resources.arsc解码成具体的资源文件）</span><br></pre></td></tr></table></figure>

<h4 id="dex2jar-代码编译-或者-jadx-代码编译"><a href="#dex2jar-代码编译-或者-jadx-代码编译" class="headerlink" title="dex2jar 代码编译 或者 jadx 代码编译"></a>dex2jar 代码编译 或者 jadx 代码编译</h4><p><strong>dex2jar</strong></p>
<p>将apk文件修改后缀为zip然后解压或者直接解压，找到<strong>classes.dex</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">d2j-dex2jar.bat classes.dex</span><br></pre></td></tr></table></figure>

<p>生成了classes-dex2jar.jar 一个jar包。</p>
<p><strong>jadx</strong></p>
<p>jadx更加方便快捷，打开bin文件中的jadx-gui.bat然后直接选择APK即可,虽然jadx也可反编译资源文件，但有时候并不准确</p>
<h4 id="jd-gui-查看jar包"><a href="#jd-gui-查看jar包" class="headerlink" title="jd-gui 查看jar包"></a>jd-gui 查看jar包</h4><p><strong>启动 jd-gui</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar jd-gui.jar</span><br></pre></td></tr></table></figure>

<p><strong>把生成的classes-dex2jar.jar 拖进去，就可以查看源码了，但是不能修改，可以帮助理解</strong></p>
<h4 id="重新打包签名"><a href="#重新打包签名" class="headerlink" title="重新打包签名"></a>重新打包签名</h4><h5 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar apktool_2.3.1.jar b KeyValueTest</span><br></pre></td></tr></table></figure>

<p>目录下会生成build和dist目录,dist 就有新的apk</p>
<h5 id="生成keystore证书"><a href="#生成keystore证书" class="headerlink" title="生成keystore证书"></a>生成keystore证书</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keytool -genkey -v -keystore myApp.keystore -<span class="built_in">alias</span> myApp.keystore -keyalg RSA -validity 30000</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>key</th>
<th>dec</th>
</tr>
</thead>
<tbody><tr>
<td>keytool</td>
<td>工具名称（固定写法）</td>
</tr>
<tr>
<td>)-genkey</td>
<td>执行的是生成数字证书操作（固定写法）</td>
</tr>
<tr>
<td>-v</td>
<td>打印生成证书的详细信息</td>
</tr>
<tr>
<td>-keystore myApp.keystore</td>
<td>生成的证书的文件名为”myApp.keystore”(根据需求，设置你的证书名)</td>
</tr>
<tr>
<td>alias myApp.keystore</td>
<td>证书的别名为”myApp.keystore”。(一般和上面的文件名相同，可以不同，但要记好，签名时会用**(A)**)</td>
</tr>
<tr>
<td>-keyalg RSA</td>
<td>生成密钥文件采用的算法为RSA(固定写法)</td>
</tr>
<tr>
<td>-validity 3000</td>
<td>该数字证书的有效期为30000天，30000天之后该证书将失效</td>
</tr>
</tbody></table>
<h5 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jarsigner -verbose -keystore myApp.keystore -signedjar android-release-signed.apk android-release-unsigned.apk myApp.keystore</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>key</th>
<th>dec</th>
</tr>
</thead>
<tbody><tr>
<td>jarsigner</td>
<td>工具称名（固定写法）</td>
</tr>
<tr>
<td>-verbose</td>
<td>显示出签名详细信息</td>
</tr>
<tr>
<td>-keystore myApp.keystore myApp.keystore</td>
<td>要使用的签名证书文件</td>
</tr>
<tr>
<td>-signedjar android-release-signed.apk</td>
<td>签名后的文件名</td>
</tr>
<tr>
<td>android-release-unsigned.apk</td>
<td>要签名的文件</td>
</tr>
<tr>
<td>myApp.keystore</td>
<td>别名，即(A)步中的别名</td>
</tr>
</tbody></table>
<p>我这个还是比较简单的流程，还有深入的smail学习，因为逆向主要还是修改smail语句。或者大佬的修改so文件，还有hook，去签名校验，还有去壳等。</p>
<p>路还是很长的。</p>
<p>例如：smail，baksmail这个软件我还没有使用到。</p>
<p>参考：</p>
<ol>
<li><a href="https://www.cnblogs.com/xiaoshen666/p/11008255.html">https://www.cnblogs.com/xiaoshen666/p/11008255.html</a></li>
<li><a href="https://blog.csdn.net/weitao_666/article/details/97615961">https://blog.csdn.net/weitao_666/article/details/97615961</a></li>
</ol>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy + scrapyd + scrapydweb + logparser + docker分布式部署</title>
    <url>/post/scrapy-scrapyd-scrapydweb-logparser-docker%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2.html</url>
    <content><![CDATA[<p>在工作中使用，特此在这记录一下，并写成docker文件，方便部署使用。</p>
<a id="more"></a>

<h5 id="1-构建-scrapyd-logparser"><a href="#1-构建-scrapyd-logparser" class="headerlink" title="1.构建 scrapyd_logparser"></a>1.构建 scrapyd_logparser</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd scrapyd_logparser</span><br><span class="line">docker build -t scrapyd_logparser .</span><br></pre></td></tr></table></figure>

<h5 id="2-运行-scrapyd-logparser"><a href="#2-运行-scrapyd-logparser" class="headerlink" title="2.运行 scrapyd_logparser"></a>2.运行 scrapyd_logparser</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6800:6800 --name scrapyd_1 scrapyd_logparser</span><br><span class="line"># docker run -d -p 6800:6800 -v &#x2F;root&#x2F;scrapyd_logparser:&#x2F;code --name scrapyd_1 scrapyd_logparser</span><br><span class="line"># 可以外联出文件 可以进行配置修改</span><br></pre></td></tr></table></figure>

<h5 id="3-构建-scrapydweb"><a href="#3-构建-scrapydweb" class="headerlink" title="3.构建 scrapydweb"></a>3.构建 scrapydweb</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd scrapydweb</span><br><span class="line">docker build -t scrapydweb .</span><br></pre></td></tr></table></figure>

<h5 id="4-运行-scrapydweb"><a href="#4-运行-scrapydweb" class="headerlink" title="4.运行 scrapydweb"></a>4.运行 scrapydweb</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v &#x2F;root&#x2F;scrapydweb:&#x2F;code --name scrapydweb scrapydweb</span><br><span class="line"># 外链出文件 好修改配置 进行更新部署</span><br><span class="line"># 修改配置</span><br><span class="line">vim scrapydweb_settings_v10.py </span><br><span class="line"># 重启</span><br><span class="line">docker restart scrapydweb</span><br></pre></td></tr></table></figure>

<h5 id="5-多机部署"><a href="#5-多机部署" class="headerlink" title="5.多机部署"></a>5.多机部署</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在其他机器中 部署 文件 执行 1，2 步</span><br><span class="line">同时在 scrapydweb 的配置文件 添加在 新主机的ip</span><br><span class="line"></span><br><span class="line"># 以下添加</span><br><span class="line">SCRAPYD_SERVERS &#x3D; [</span><br><span class="line">    &#39;192.168.5.131:6800&#39;,</span><br><span class="line">    &#39;192.168.5.131:6805&#39;,</span><br><span class="line">    # &#39;username:password@localhost:6801#group&#39;,</span><br><span class="line">    # (&#39;username&#39;, &#39;password&#39;, &#39;localhost&#39;, &#39;6801&#39;, &#39;group&#39;),</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>源码</strong>: <a href="https://github.com/libaibuaidufu/scrapyd_web_log">https://github.com/libaibuaidufu/scrapyd_web_log</a><br><strong>注</strong>： 可以自己查看 一下 scrapydweb 配置文件 修改，和 scrapyd 配置文件修改</p>
<p>参考：</p>
<ol>
<li><a href="https://github.com/my8100/scrapydweb">scrapydweb</a></li>
<li><a href="https://github.com/my8100/logparser">logparser</a></li>
</ol>
]]></content>
      <categories>
        <category>代码来了</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>转载-flask源码分析</title>
    <url>/post/%E8%BD%AC%E8%BD%BD-flask%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
    <content><![CDATA[<p>本来想着写第二篇的，但是一直没有什么头绪，就把以前自己看过的文章转载一下，同时在温故而知新。然后在根据理解在进行写。我要转载也是因为别人写的好很详细。</p>
<p>同时还有更详细的 就是此作者在后面的参考中的。当然我也是看过的，别人写的更加详细。以模块分类进行深度讲解。</p>
<p>看了下面两篇可以让你对Flask有着更深的认识。</p>
<p>后续我也会写一些自己的认识。</p>
<a id="more"></a>

<p>转载：<a href="https://juejin.im/post/6844903533238566925">flask 源码解析</a></p>
<p>文章系列：<a href="https://cizixs.com/2017/01/10/flask-insight-introduction/">flask 源码解析：简介</a></p>
<h1 id="flask-源码解析"><a href="#flask-源码解析" class="headerlink" title="flask 源码解析"></a>flask 源码解析</h1><p>本文简单的分析了 Flask 的源码，主要关注 WSGI、Flask 对象的数据结构、Flask 应用启动过程、请求处理过程、视图函数、URL 的映射、应用上下文和请求上下文。讲解这些主题时也不会面面俱到，请按照你阅读源码的需要自行探索。要读懂本文，你需要较为熟悉 Flask，比如已经用 Flask 写过一个小项目，并且有一定的阅读代码的能力，并对 web 框架的功能有基本了解。</p>
<p>本文会不时更新，最近更新日期：2017年9月10日。</p>
<p>这是 Flask 官方钦定的 Demo 代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(‘/‘)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> ‘Hello, world!’</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == ‘__main__’:</span><br><span class="line">    app.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这篇文章从这个简单的代码开始，简要介绍了 WSGI、Flask 对象的数据结构、Flask 应用启动过程、请求处理过程、视图函数、URL 的映射、request 和 response 类（应用上下文和请求上下文），这些主题涵盖了一个 web 框架的核心。</p>
<h2 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h2><p>在用户发起的请求到达服务器之后，会被一个 HTTP 服务器所接收，然后交给 web 应用程序做业务处理，这样 HTTP 服务器和 web 应用之间就需要一个接口，在 Python web 开发的世界里，Python 官方<strong>钦定</strong>了这个接口并命名为 WSGI，由 PEP333 所规定。只要服务器和框架都遵守这个约定，那么就能实现服务器和框架的任意组合。按照这个规定，一个面向 WSGI 的框架必须要实现这个方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span>(<span class="params">environ, start_response</span>)</span></span><br></pre></td></tr></table></figure>

<p>在工作过程中，HTTP 服务器会调用上面这个方法，传入请求信息，即名为 <code>environ</code> 的字典和 <code>start_response</code> 函数，应用从 <code>environ</code> 中获取请求信息，在进行业务处理后调用 <code>start_response</code> 设置响应头，并返回响应体（必须是一个可遍历的对象，比如列表、字典）给 HTTP 服务器，HTTP 服务器再返回响应给用户。</p>
<p>所以 Flask 作为一个开发 web 应用的 web 框架，负责解决的问题就是：</p>
<ol>
<li>作为一个应用，能够被 HTTP 服务器所调用，必须要有 <code>__call__</code> 方法</li>
<li>通过传入的请求信息（URL、HTTP 方法等），找到正确的业务处理逻辑，即正确的视图函数</li>
<li>处理业务逻辑，这些逻辑可能包括表单检查、数据库 CRUD 等（这个在这篇文章里不会涉及）</li>
<li>返回正确的响应</li>
<li>在同时处理多个请求时，还需要保护这些请求，知道应该用哪个响应去匹配哪个请求，即线程保护</li>
</ol>
<p>下面就来看看 Flask 是如何解决这些问题的。</p>
<blockquote>
<p>参考阅读：<a href="http://python.jobbole.com/81524/">一起写一个 web 服务器</a>，该系列文章能够让你基本理解 web 服务器和框架是如何通过 WSGI 协同工作的。</p>
</blockquote>
<h2 id="应用的创建"><a href="#应用的创建" class="headerlink" title="应用的创建"></a>应用的创建</h2><blockquote>
<p>源码阅读：<code>app.py</code> 中 <code>Flask</code> 类的代码。</p>
</blockquote>
<p>Demo 代码的第二行创建了一个 Flask 类的实例，传入的参数是当前模块的名字。我们先来看看 Flask 应用到底是什么，它的数据结构是怎样的。</p>
<p><code>Flask</code> 是这样一个类：</p>
<blockquote>
<p>The flask object implements a WSGI application and acts as the central object. It is passed the name of the module or package of the application. Once it is created it will act as a central registry for the view functions, the URL rules, template configuration and much more.</p>
</blockquote>
<blockquote>
<p>The name of the package is used to resolve resources from inside the package or the folder the module is contained in depending on if the package parameter resolves to an actual python package (a folder with an <code>__init__.py</code> file inside) or a standard module (just a <code>.py</code> file).</p>
</blockquote>
<blockquote>
<p>一个 Flask 对象实际上是一个 WSGI 应用。它接收一个模块或包的名字作为参数。它被创建之后，所有的视图函数、URL 规则、模板设置等都会被注册到它上面。之所以要传入模块或包的名字，是为了定位一些资源。</p>
</blockquote>
<p>Flask 类有这样一些属性：</p>
<ul>
<li><code>request_class = Request</code> 设置请求的类型</li>
<li><code>response_class = Response</code> 设置响应的类型</li>
</ul>
<p>这两个类型都来源于它的依赖库 <code>werkzeug</code> 并做了简单的拓展。</p>
<p>Flask 对象的 <code>__init__</code> 方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, package_name</span>):</span></span><br><span class="line">    <span class="comment">#: Flask 对象有这样一个字典来保存所有的视图函数</span></span><br><span class="line">    self.view_functions = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#: 这个字典用来保存所有的错误处理视图函数</span></span><br><span class="line">    <span class="comment">#: 字典的 key 是错误类型码</span></span><br><span class="line">    self.error_handlers = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#: 这个列表用来保存在请求被分派之前应当执行的函数</span></span><br><span class="line">    self.before_request_funcs = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">#: 在接收到第一个请求的时候应当执行的函数</span></span><br><span class="line">    self.before_first_request_funcs = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">#: 这个列表中的函数在请求完成之后被调用，响应对象会被传给这些函数</span></span><br><span class="line">    self.after_request_funcs = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">#: 这里设置了一个 url_map 属性，并把它设置为一个 Map 对象</span></span><br><span class="line">    self.url_map = Map()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到这里一个 Flask 对象创建完毕并被变量 <code>app</code> 所指向，其实它就是一个保存了一些配置信息，绑定了一些视图函数并且有个 URL 映射对象（<code>url_map</code>）的对象。但我们还不知道这个 Map 对象是什么，有什么作用，从名字上看，似乎其作用是映射 URL 到视图函数。源代码第 21 行有 <code>from werkzeug.routing import Map, Rule</code>，那我们就来看看 <code>werkzeug</code> 这个库中对 Map 的定义：</p>
<blockquote>
<p>The map class stores all the URL rules and some configuration parameters. Some of the configuration values are only stored on the <code>Map</code> instance since those affect all rules, others are just defaults and can be overridden for each rule. Note that you have to specify all arguments besides the <code>rules</code> as keyword arguments!</p>
</blockquote>
<p>可以看到这个类的对象储存了所有的 URL 规则和一些配置信息。由于 <code>werkzeug</code> 的映射机制比较复杂，我们下文中讲到映射机制的时候再深入了解，现在只要记住 Flask 应用（即一个 <code>Flask</code> 类的实例）存储了视图函数，并通过 <code>url_map</code> 这个变量存储了一个 URL 映射机构就可以了。</p>
<h2 id="应用启动过程"><a href="#应用启动过程" class="headerlink" title="应用启动过程"></a>应用启动过程</h2><blockquote>
<p>源码阅读：<code>app.py</code> 中 <code>Flask</code> 类的代码和 <code>werkzeug.serving</code> 的代码，特别注意 <code>run_simple</code> <code>BaseWSGIServer</code> <code>WSGIRequestHandler</code>。</p>
</blockquote>
<p>Demo 代码的第 6 行是一个限制，表示如果 Python 解释器是直接运行该文件或包的，则运行 Flask 程序：在 Python 中，如果直接执行一个模块或包，那么解释器就会把当前模块或包的 <code>__name__</code> 设置为为 <code>__main_</code>。</p>
<p>第 7 行中的 <code>run</code> 方法启动了 Flask 应用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, host=None, port=None, debug=None, **options</span>):</span></span><br><span class="line">    <span class="keyword">from</span> werkzeug.serving <span class="keyword">import</span> run_simple</span><br><span class="line">    <span class="keyword">if</span> host <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        host = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> port <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        server_name = self.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> server_name <span class="keyword">and</span> <span class="string">&#x27;:&#x27;</span> <span class="keyword">in</span> server_name:</span><br><span class="line">            port = int(server_name.rsplit(<span class="string">&#x27;:&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            port = <span class="number">5000</span></span><br><span class="line">    <span class="keyword">if</span> debug <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self.debug = bool(debug)</span><br><span class="line">    options.setdefault(<span class="string">&#x27;use_reloader&#x27;</span>, self.debug)</span><br><span class="line">    options.setdefault(<span class="string">&#x27;use_debugger&#x27;</span>, self.debug)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        run_simple(host, port, self, **options)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># reset the first request information if the development server</span></span><br><span class="line">        <span class="comment"># reset normally.  This makes it possible to restart the server</span></span><br><span class="line">        <span class="comment"># without reloader and that stuff from an interactive shell.</span></span><br><span class="line">        self._got_first_request = <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到这个方法基本上是在配置参数，实际上启动服务器的是 <code>werkzeug</code> 的 <code>run_simple</code> 方法，该方法在默认情况下启动了服务器 <code>BaseWSGIServer</code>，继承自 Python 标准库中的 <code>HTTPServer.TCPServer</code>。注意在调用 <code>run_simple</code> 时，Flask 对象把自己 <code>self</code> 作为参数传进去了，这是正确的，因为服务器在收到请求的时候，必须要知道应该去调用谁的 <code>__call__</code> 方法。</p>
<p>按照标准库中 <code>HTTPServer.TCPServer</code> 的模式，服务器必须有一个类来作为 request handler 来处理收到的请求，而不是由 <code>HTTPServer.TCPServer</code> 本身的实例来处理，<code>werkzeug</code> 提供了 <code>WSGIRequestHandler</code> 类来作为 request handler，这个类在被 <code>BaseWSGIServer</code> 调用时，会执行这个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">app</span>):</span></span><br><span class="line">    application_iter = app(environ, start_response)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> application_iter:</span><br><span class="line">            write(data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headers_sent:</span><br><span class="line">            write(<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> hasattr(application_iter, <span class="string">&#x27;close&#x27;</span>):</span><br><span class="line">            application_iter.close()</span><br><span class="line">        application_iter = <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数的第一行就是按照 WSGI 要求的，调用了 app 并把 <code>environ</code> 和 <code>start_response</code> 传入。我们再看看 flask 中是如何按照 WSGI 要求对服务器的调用进行呼应的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, environ, start_response</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self.wsgi_app(environ, start_response)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span>(<span class="params">self, environ, start_response</span>):</span></span><br><span class="line">    ctx = self.request_context(environ)</span><br><span class="line">    ctx.push()</span><br><span class="line">    error = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = self.full_dispatch_request()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            error = e</span><br><span class="line">            response = self.handle_exception(e)</span><br><span class="line">        <span class="keyword">return</span> response(environ, start_response)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> self.should_ignore_error(error):</span><br><span class="line">            error = <span class="literal">None</span></span><br><span class="line">        ctx.auto_pop(error)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到 Flask 按照 WSGI 的要求实现了 <code>__call__</code> 方法，因此成为了一个可调用的对象。但它不是在直接在 <code>__call__</code> 里写逻辑的，而是调用了 <code>wsgi_app</code> 方法，这是为了中间件的考虑，不展开谈了。这个方法返回的 <code>response(environ, start_response)</code> 中，<code>response</code> 是 <code>werkzueg.response</code> 类的一个实例，它也是个可以调用的对象，这个对象会负责生成最终的可遍历的响应体，并调用 <code>start_response</code> 形成响应头。</p>
<h2 id="请求处理过程"><a href="#请求处理过程" class="headerlink" title="请求处理过程"></a>请求处理过程</h2><blockquote>
<p>源码阅读：<code>app.Flask</code> 的代码。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span>(<span class="params">self, environ, start_response</span>):</span></span><br><span class="line">    ctx = self.request_context(environ)</span><br><span class="line">    ctx.push()</span><br><span class="line">    error = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = self.full_dispatch_request()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            error = e</span><br><span class="line">            response = self.handle_exception(e)</span><br><span class="line">        <span class="keyword">return</span> response(environ, start_response)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> self.should_ignore_error(error):</span><br><span class="line">            error = <span class="literal">None</span></span><br><span class="line">        ctx.auto_pop(error)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>wsgi_app</code> 方法中里面的内容就是对请求处理过程的一个高度抽象。</p>
<p>首先，在接收到服务器传过来的请求时，Flask 调用 <code>request_context</code> 函数建立了一个 <code>RequestContext</code> 请求上下文对象，并把它压入 <code>_request_ctx_stack</code> 栈。关于上下文和栈的内容下文会再讲到，你现在需要知道的是，这些操作是为了 flask 在处理多个请求的时候不会混淆。之后，Flask 会调用 <code>full_dispatch_request</code> 方法对这个请求进行分发，开始实际的请求处理过程，这个过程中会生成一个响应对象并最终通过调用 <code>response</code> 对象来返回给服务器。如果当中出错，就声称相应的错误信息。不管是否出错，最终 Flask 都会把请求上下文推出栈。</p>
<p><code>full_dispatch_request</code> 是请求分发的入口，我们再来看它的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">full_dispatch_request</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.try_trigger_before_first_request_functions()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rv = self.preprocess_request()</span><br><span class="line">        <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            rv = self.dispatch_request()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        rv = self.handle_user_exception(e)</span><br><span class="line">    <span class="keyword">return</span> self.finalize_request(rv)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先调用 <code>try_trigger_before_first_request_functions</code> 方法来尝试调用 <code>before_first_request</code> 列表中的函数，如果 <code>Flask</code> 的 <code>_got_first_request</code> 属性为 <code>False</code>，<code>before_first_request</code> 中的函数就会被执行，执行一次之后，<code>_got_first_request</code> 就会被设置为 <code>True</code> 从而不再执行这些函数。</p>
<p>然后调用 <code>preprocess_request</code> 方法，这个方法调用 <code>before_request_funcs</code> 列表中所有的方法，如果这些 <code>before_request_funcs</code> 方法中返回了某种东西，那么就不会真的去分发这个请求。比如说，一个 <code>before_request_funcs</code> 方法是用来检测用户是否登录的，如果用户没有登录，那么这个方法就会调用 <code>abort</code> 方法从而返回一个错误，Flask 就不会分发这个请求而是直接报 401 错误。</p>
<p>如果 <code>before_request_funcs</code> 中的函数没有返回，那么再调用 <code>dispatch_request</code> 方法进行请求分发。这个方法首先会查看 URL 规则中有没有相应的 <code>endpoint</code> 和 <code>value</code> 值，如果有，那么就调用 <code>view_functions</code> 中相应的视图函数（<code>endpoint</code> 作为键值）并把参数值传入（<code>**req.view_args</code>），如果没有就由 <code>raise_routing_exception</code> 进行处理。视图函数的返回值或者错误处理视图函数的返回值会返回给 <code>wsgi_app</code> 方法中的 <code>rv</code> 变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch_request</span>(<span class="params">self</span>):</span></span><br><span class="line">        req = _request_ctx_stack.top.request</span><br><span class="line">        <span class="keyword">if</span> req.routing_exception <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.raise_routing_exception(req)</span><br><span class="line">        rule = req.url_rule</span><br><span class="line">        <span class="keyword">if</span> getattr(rule, <span class="string">&#x27;provide_automatic_options&#x27;</span>, <span class="literal">False</span>) \</span><br><span class="line">           <span class="keyword">and</span> req.method == <span class="string">&#x27;OPTIONS&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self.make_default_options_response()</span><br><span class="line">        <span class="keyword">return</span> self.view_functions[rule.endpoint](**req.view_args)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">finalize_request</span>(<span class="params">self, rv, from_error_handler=False</span>):</span></span><br><span class="line">    response = self.make_response(rv)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = self.process_response(response)</span><br><span class="line">        request_finished.send(self, response=response)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> from_error_handler:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        self.logger.exception(<span class="string">&#x27;Request finalizing failed with an &#x27;</span></span><br><span class="line">                              <span class="string">&#x27;error while handling an error&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_response</span>(<span class="params">self, rv</span>):</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(rv, self.response_class):</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line">    <span class="keyword">if</span> isinstance(rv, basestring):</span><br><span class="line">        <span class="keyword">return</span> self.response_class(rv)</span><br><span class="line">    <span class="keyword">if</span> isinstance(rv, tuple):</span><br><span class="line">        <span class="keyword">return</span> self.response_class(*rv)</span><br><span class="line">    <span class="keyword">return</span> self.response_class.force_type(rv, request.environ)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后 Flask 就会根据 <code>rv</code> 生成响应，这个 <code>make_response</code> 方法会查看 rv 是否是要求的返回值类型，否则生成正确的返回类型。比如 Demo 中返回值是字符串，就会满足 <code>isinstance(rv, basestring)</code> 判断并从字符串生成响应。这一步完成之后，Flask 查看是否有后处理视图函数需要执行（在 <code>process_response</code> 方法中），并最终返回一个完全处理好的 <code>response</code> 对象。</p>
<h2 id="视图函数注册"><a href="#视图函数注册" class="headerlink" title="视图函数注册"></a>视图函数注册</h2><p>在请求处理过程一节中，我们已经看到了 Flask 是如何调用试图函数的，这一节我们要关注 Flask 如何构建和请求分派相关的数据结构。我们将主要关注 <code>view_functions</code>，因为其他的数据结构如 <code>before_request_funcs</code> 的构建过程大同小异，甚至更为简单。我们也将仔细讲解在应用的创建一节中遗留的问题，即 <code>url_map</code> 到底是什么。</p>
<p>Demo 代码的第 4 行用修饰器 <code>route</code> 注册一个视图函数，这是 Flask 中受到广泛称赞的一个设计。在 Flask 类的 <code>route</code> 方法中，可以看到它调用了 <code>add_url_rule</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">route</span>(<span class="params">self, rule, **options</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">f</span>):</span></span><br><span class="line">        endpoint = options.pop(<span class="string">&#x27;endpoint&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">        self.add_url_rule(rule, endpoint, f, **options)</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_url_rule</span>(<span class="params">self, rule, endpoint, **options</span>):</span></span><br><span class="line">    <span class="keyword">if</span> endpoint <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        endpoint = _endpoint_from_view_func(view_func)</span><br><span class="line">    options[<span class="string">&#x27;endpoint&#x27;</span>] = endpoint</span><br><span class="line">    methods = options.pop(<span class="string">&#x27;methods&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> methods <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        methods = getattr(view_func, <span class="string">&#x27;methods&#x27;</span>, <span class="literal">None</span>) <span class="keyword">or</span> (<span class="string">&#x27;GET&#x27;</span>,)</span><br><span class="line">    <span class="keyword">if</span> isinstance(methods, string_types):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&#x27;Allowed methods have to be iterables of strings, &#x27;</span></span><br><span class="line">                        <span class="string">&#x27;for example: @app.route(..., methods=[&quot;POST&quot;])&#x27;</span>)</span><br><span class="line">    methods = set(item.upper() <span class="keyword">for</span> item <span class="keyword">in</span> methods)</span><br><span class="line"></span><br><span class="line">    required_methods = set(getattr(view_func, <span class="string">&#x27;required_methods&#x27;</span>, ()))</span><br><span class="line"></span><br><span class="line">    provide_automatic_options = getattr(view_func,</span><br><span class="line">        <span class="string">&#x27;provide_automatic_options&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> provide_automatic_options <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;OPTIONS&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> methods:</span><br><span class="line">            provide_automatic_options = <span class="literal">True</span></span><br><span class="line">            required_methods.add(<span class="string">&#x27;OPTIONS&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            provide_automatic_options = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    methods |= required_methods</span><br><span class="line"></span><br><span class="line">    rule = self.url_rule_class(rule, methods=methods, **options)</span><br><span class="line">    rule.provide_automatic_options = provide_automatic_options</span><br><span class="line"></span><br><span class="line">    self.url_map.add(rule)</span><br><span class="line">    <span class="keyword">if</span> view_func <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        old_func = self.view_functions.get(endpoint)</span><br><span class="line">        <span class="keyword">if</span> old_func <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> old_func != view_func:</span><br><span class="line">            <span class="keyword">raise</span> AssertionError(<span class="string">&#x27;View function mapping is overwriting an &#x27;</span></span><br><span class="line">                                 <span class="string">&#x27;existing endpoint function: %s&#x27;</span> % endpoint)</span><br><span class="line">        self.view_functions[endpoint] = view_func</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个方法负责注册视图函数，并实现 URL 到视图函数的映射。首先，它要准备好一个视图函数所支持的 HTTP 方法（基本上一半多的代码都是在做这个），然后通过 <code>url_rule_class</code> 创建一个 <code>rule</code> 对象，并把这个对象添加到自己的 <code>url_map</code> 里。我们那个遗留问题在这里就得到解答了：<code>rule</code> 对象是一个保存合法的（Flask 应用所支持的） URL、方法、<code>endpoint</code>（在 <code>**options</code> 中） 及它们的对应关系的数据结构，而 <code>url_map</code> 是保存这些对象的集合。然后，这个方法将视图函数添加到 <code>view_functions</code> 当中，<code>endpoint</code> 作为它的键，其值默认是函数名。</p>
<p>我们再来深入了解一下 <code>rule</code> ，它被定义在 <code>werkzeug.routing.Rule</code> 中：</p>
<blockquote>
<p>A Rule represents one URL pattern. There are some options for <code>Rule</code> that change the way it behaves and are passed to the <code>Rule</code> constructor. 一个 Rule 对象代表了一种 URL 模式，可以通过传入参数来改变它的许多行为。</p>
</blockquote>
<p>Rule 的 <code>__init__</code> 方法为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, string, defaults=None, subdomain=None, methods=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 build_only=False, endpoint=None, strict_slashes=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 redirect_to=None, alias=False, host=None</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> string.startswith(<span class="string">&#x27;/&#x27;</span>):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;urls must start with a leading slash&#x27;</span>)</span><br><span class="line">    self.rule = string</span><br><span class="line">    self.is_leaf = <span class="keyword">not</span> string.endswith(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    self.map = <span class="literal">None</span></span><br><span class="line">    self.strict_slashes = strict_slashes</span><br><span class="line">    self.subdomain = subdomain</span><br><span class="line">    self.host = host</span><br><span class="line">    self.defaults = defaults</span><br><span class="line">    self.build_only = build_only</span><br><span class="line">    self.alias = alias</span><br><span class="line">    <span class="keyword">if</span> methods <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.methods = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> isinstance(methods, str):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;param `methods` should be `Iterable[str]`, not `str`&#x27;</span>)</span><br><span class="line">        self.methods = set([x.upper() <span class="keyword">for</span> x <span class="keyword">in</span> methods])</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;HEAD&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> self.methods <span class="keyword">and</span> <span class="string">&#x27;GET&#x27;</span> <span class="keyword">in</span> self.methods:</span><br><span class="line">            self.methods.add(<span class="string">&#x27;HEAD&#x27;</span>)</span><br><span class="line">    self.endpoint = endpoint</span><br><span class="line">    self.redirect_to = redirect_to</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> defaults:</span><br><span class="line">        self.arguments = set(map(str, defaults))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.arguments = set()</span><br><span class="line">    self._trace = self._converters = self._regex = self._weights = <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个 Rule 被创建后，通过 <code>Map</code> 的 <code>add</code> 方法被绑定到 <code>Map</code> 对象上，我们之前说过 <code>flask.url_map</code> 就是一个 <code>Map</code> 对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, rulefactory</span>):</span></span><br><span class="line">    <span class="keyword">for</span> rule <span class="keyword">in</span> rulefactory.get_rules(self):</span><br><span class="line">        rule.bind(self)</span><br><span class="line">        self._rules.append(rule)</span><br><span class="line">        self._rules_by_endpoint.setdefault(rule.endpoint, []).append(rule)</span><br><span class="line">    self._remap = <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而 <code>Rule</code> 的 <code>bind</code> 方法的内容，就是添加 <code>Rule</code> 对应的 <code>Map</code>，然后调用 <code>compile</code> 方法生成一个正则表达式，<code>compile</code> 方法比较复杂，就不展开了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bind</span>(<span class="params">self, map, rebind=False</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Bind the url to a map and create a regular expression based on</span></span><br><span class="line"><span class="string">    the information from the rule itself and the defaults from the map.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :internal:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> self.map <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> rebind:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;url rule %r already bound to map %r&#x27;</span> %</span><br><span class="line">                           (self, self.map))</span><br><span class="line">    self.map = map</span><br><span class="line">    <span class="keyword">if</span> self.strict_slashes <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.strict_slashes = map.strict_slashes</span><br><span class="line">    <span class="keyword">if</span> self.subdomain <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.subdomain = map.default_subdomain</span><br><span class="line">    self.compile()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 Flask 应用收到请求时，这些被绑定到 <code>url_map</code> 上的 <code>Rule</code> 会被查看，来找到它们对应的视图函数。这是在请求上下文中实现的，我们先前在 <code>dispatch_request</code> 方法中就见过——我们是从 <code>_request_ctx_stack.top.request</code> 得到 <code>rule</code> 并从这个 <code>rule</code> 找到 <code>endpoint</code>，最终找到用来处理该请求的正确的视图函数的。所以，接下来我们需要看请求上下的具体实现，并且看一看 Flask 是如何从 <code>url_map</code> 中找到这个 <code>rule</code> 的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch_request</span>(<span class="params">self</span>):</span></span><br><span class="line">    req = _request_ctx_stack.top.request</span><br><span class="line">    <span class="keyword">if</span> req.routing_exception <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self.raise_routing_exception(req)</span><br><span class="line">    rule = req.url_rule</span><br><span class="line">    <span class="keyword">if</span> getattr(rule, <span class="string">&#x27;provide_automatic_options&#x27;</span>, <span class="literal">False</span>) \</span><br><span class="line">       <span class="keyword">and</span> req.method == <span class="string">&#x27;OPTIONS&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> self.make_default_options_response()</span><br><span class="line">    <span class="keyword">return</span> self.view_functions[rule.endpoint](**req.view_args)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="请求上下文"><a href="#请求上下文" class="headerlink" title="请求上下文"></a>请求上下文</h2><blockquote>
<p>源码阅读：<code>ctx.RequestContext</code> 的代码。</p>
</blockquote>
<p>请求上下文是如何、在何时被创建的呢？我们先前也见过，在服务器调用应用的时候，Flask 的 <code>wsgi_app</code> 中有这样的语句，就是创建了请求上下文并压栈。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span>(<span class="params">self, environ, start_response</span>):</span></span><br><span class="line">    ctx = self.request_context(environ)</span><br><span class="line">    ctx.push()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>request_context</code> 方法非常简单，就是创建了 <code>RequestContext</code> 类的一个实例，这个类被定义在 <code>flask.ctx</code> 文件中，它包含了一系列关于请求的信息，<strong>最重要的是</strong>它自身的 <code>request</code> 属性指向了一个 <code>Request</code> 类的实例，这个类继承自 <code>werkzeug.Request</code>，在 <code>RequestContext</code> 的创建过程中，它会根据传入的 <code>environ</code> 创建一个 <code>werkzeug.Request</code> 的实例。</p>
<p>接着 <code>RequestContext</code> 的 <code>push</code> 方法被调用，这个方法将自己推到 <code>_request_ctx_stack</code> 的栈顶。</p>
<p><code>_request_ctx_stack</code> 被定义在 <code>flask.global</code> 文件中，它是一个 <code>LocalStack</code> 类的实例，是 <code>werkzeug.local</code> 所实现的，如果你对 Python 的 threading 熟悉的话，就会发现这里实现了线程隔离，就是说，在 Python 解释器运行到 <code>_request_ctx_stack</code> 相关代码的时候，解释器会根据当前进程来选择正确的实例。</p>
<p>但是，在整个分析 Flask 源码的过程中，我们也没发现 Flask 在被调用之后创建过线程啊，那么为什么要做线程隔离呢？看我们开头提到的 <code>run</code> 函数，其实它可以传一个 <code>threaded</code> 参数。当不传这个函数的时候，我们启动的是 <code>BasicWSGIServer</code>，这个服务器是单线程单进程的，Flask 的线程安全自然没有意义，但是当我们传入这个参数的时候，我们启动的是 <code>ThreadedWSGIServer</code>，这时 Flask 的线程安全就是有意义的了，在其他多线程的服务器中也是一样。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="一个请求的旅程"><a href="#一个请求的旅程" class="headerlink" title="一个请求的旅程"></a>一个请求的旅程</h3><p>这里，我们通过追踪一个请求到达服务器并返回（当然是通过“变成”一个相应）的旅程，串讲本文的内容。</p>
<ol>
<li>在请求发出之前，Flask 注册好了所有的视图函数和 URL 映射，服务器在自己身上注册了 Flask 应用。</li>
<li>请求到达服务器，服务器准备好 <code>environ</code> 和 <code>make_response</code> 函数，然后调用了自己身上注册的 Flask 应用。</li>
<li>应用实现了 WSGI 要求的 <code>application(environ, make_response)</code> 方法。在 Flask 中，这个方法是个被 <code>__call__</code> 中转的叫做 <code>wsgi_app</code> 的方法。它首先通过 <code>environ</code> 创建了请求上下文，并将它推入栈，使得 flask 在处理当前请求的过程中都可以访问到这个请求上下文。</li>
<li>然后 Flask 开始处理这个请求，依次调用 <code>before_first_request_funcs</code> <code>before_request_funcs</code> <code>view_functions</code> 中的函数，并最终通过 <code>finalize_request</code> 生成一个 <code>response</code> 对象，当中只要有函数返回值，后面的函数组就不会再执行，<code>after_request_funcs</code> 进行 <code>response</code> 生成后的后处理。</li>
<li>Flask 调用这个 <code>response</code> 对象，最终调用了 <code>make_response</code> 函数，并返回了一个可遍历的响应内容。</li>
<li>服务器发送响应。</li>
</ol>
<h3 id="Flask-和-werkzeug"><a href="#Flask-和-werkzeug" class="headerlink" title="Flask 和 werkzeug"></a>Flask 和 werkzeug</h3><p>在分析过程中，可以很明显地看出 Flask 和 <code>werkzeug</code> 是强耦合的，实际上 <code>werkzeug</code> 是 Flask 唯一不可或缺的依赖，一些非常细节的工作，其实都是 <code>werkzeug</code> 库完成的，在本文的例子中，它至少做了这些事情：</p>
<ol>
<li>封装 <code>Response</code> 和 <code>Request</code> 类型供 Flask 使用，在实际开发中，我们在请求和响应对象上的操作，调用的其实是 <code>werkzeug</code> 的方法。</li>
<li>实现 URL 到视图函数的映射，并且能把 URL 中的参数传给该视图函数。我们看到了 Flask 的 url_map 属性并且看到了它如何绑定视图函数和错误处理函数，但是具体的映射规则的实践，和在响应过程中的 URL 解析，都是由 werkzeug 完成的。</li>
<li>通过 LocalProxy 类生成的 <code>_request_ctx_stack</code> 对 Flask 实现线程保护。</li>
</ol>
<p>对于 Flask 的源码分析先暂时到这里。有时间的话，我会分析 Flask 中的模板渲染、<code>import request</code>、蓝图和一些好用的变量及函数，或者深入分析 <code>werkzeug</code> 库。</p>
<h3 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h3><ol>
<li><a href="http://cizixs.com/2017/01/10/flask-insight-introduction">flask 源码解析系列文章</a>，你可以在读完本文了解主线之后，再看这系列文章了解更加细节的东西。</li>
<li><a href="http://python.jobbole.com/81524/">一起写一个 web 服务器</a>。</li>
</ol>
<h2 id="文章更新记录"><a href="#文章更新记录" class="headerlink" title="文章更新记录"></a>文章更新记录</h2><ul>
<li>2017年9月10日：利用 0.12.0 版本进行分析，重新调整了结构和行文顺序，增加了许多内容。</li>
</ul>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
</search>
